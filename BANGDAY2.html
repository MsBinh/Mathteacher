<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>B·∫¢NG D·∫†Y v4.1 (MOBILE FIX)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    <style>
        /* C·∫§U H√åNH C∆† B·∫¢N */
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #2c3e50; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        .app-layout { display: flex; flex-direction: column; height: 100vh; }
        
        /* THANH C√îNG C·ª§ (Cho ph√©p tr∆∞·ª£t ngang n·∫øu nhi·ªÅu n√∫t qu√°) */
        .toolbar {
            height: 50px; background: #ecf0f1; display: flex; align-items: center; padding: 0 10px; gap: 8px; border-bottom: 1px solid #bdc3c7; flex-shrink: 0; 
            overflow-x: auto; /* Cho ph√©p tr∆∞·ª£t thanh c√¥ng c·ª• tr√™n ƒëi·ªán tho·∫°i */
            white-space: nowrap;
        }
        /* ·∫®n thanh cu·ªôn c·ªßa toolbar cho ƒë·∫πp */
        .toolbar::-webkit-scrollbar { display: none; }

        .btn { padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-weight: bold; background: white; font-size: 14px; }
        .btn.active { background: #2980b9; color: white; border-color: #2980b9; }
        
        select.shape-select { padding: 8px; border-radius: 4px; border: 1px solid #ccc; font-weight: bold; color: #2c3e50; max-width: 120px; font-size: 14px; }
        .color-group { display: flex; gap: 8px; margin-left: auto; margin-right: 5px;}
        .color-btn { width: 30px; height: 30px; border-radius: 50%; border: 2px solid #fff; flex-shrink: 0; }
        .color-btn.active { transform: scale(1.2); border-color: #333; }

        /* V√ôNG CH·ª®A PDF (QUAN TR·ªåNG: CHO PH√âP TR∆Ø·ª¢T 2 CHI·ªÄU) */
        #mainContainer {
            flex: 1; 
            position: relative; 
            text-align: center; 
            background-color: #555; 
            padding-bottom: 50px; 
            
            /* CHO PH√âP CU·ªòN C·∫¢ 2 CHI·ªÄU (NGANG + D·ªåC) */
            overflow: auto; 
            
            /* M·∫∑c ƒë·ªãnh cho ph√©p tr∆∞·ª£t b·∫±ng tay (khi ·ªü ch·∫ø ƒë·ªô Hand) */
            touch-action: pan-x pan-y; 
            -webkit-overflow-scrolling: touch; /* M∆∞·ª£t m√† tr√™n iPhone */
        }
        
        /* KHI ƒêANG V·∫º: KH√ìA CH·∫∂T M·ªåI H∆Ø·ªöNG CU·ªòN ƒê·ªÇ KH√îNG B·ªä TR√îI GI·∫§Y */
        body.drawing-mode #mainContainer { 
            touch-action: none; 
            overflow: hidden; /* ·∫®n thanh cu·ªôn t·∫°m th·ªùi ƒë·ªÉ t·∫≠p trung v·∫Ω */
        }

        .page-wrapper { display: inline-block; position: relative; margin: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); line-height: 0; }
        .pdf-canvas { display: block; background: white; }
        .draw-canvas { position: absolute; top: 0; left: 0; cursor: crosshair; touch-action: none; }

        /* Ch·∫ø ƒë·ªô Tay: Canvas v·∫Ω xuy√™n th·∫•u ƒë·ªÉ ch·∫°m v√†o v√πng cu·ªôn b√™n d∆∞·ªõi */
        body.hand-mode .draw-canvas { pointer-events: none; }
        body.hand-mode #mainContainer { cursor: grab; overflow: auto; } 

        /* Web Window */
        .web-window { position: absolute; width: 300px; height: 400px; background: white; border: 2px solid #3498db; top: 60px; left: 20px; display: flex; flex-direction: column; box-shadow: 0 10px 25px rgba(0,0,0,0.5); z-index: 2000; resize: both; overflow: hidden; }
        .web-header { padding: 8px; background: #3498db; color: white; display: flex; justify-content: space-between; align-items: center; font-weight: bold; }
        .web-content { flex: 1; position: relative; }
        iframe { width: 100%; height: 100%; border: none; }
        .web-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .drawing-web .web-overlay { pointer-events: auto; background: rgba(0,0,0,0.05); cursor: crosshair; }
        :fullscreen .toolbar { display: flex; }
    </style>
</head>
<body class="drawing-mode">

<div class="app-layout" id="app">
    <div class="toolbar">
        <button class="btn" onclick="toggleFullScreen()" title="Full m√†n h√¨nh">üñ•Ô∏è</button>
        <button class="btn" onclick="document.getElementById('pdfInput').click()">üìÇ</button>
        <button class="btn" onclick="loadPdfFromPrompt()">üîó</button>
        <button class="btn" onclick="addWebsite()">üåê</button>
        <input type="file" id="pdfInput" accept=".pdf" style="display: none;">

        <div style="width: 1px; height: 25px; background: #ccc; margin: 0 5px;"></div>
        
        <button class="btn active" id="btnPen" onclick="setTool('pen')">‚úèÔ∏è</button>
        <button class="btn" id="btnHighlighter" onclick="setTool('highlighter')">üñçÔ∏è</button>
        <button class="btn" id="btnEraser" onclick="setTool('eraser')">T·∫©y</button>

        <div style="width: 1px; height: 25px; background: #ccc; margin: 0 5px;"></div>

        <button class="btn" id="btnLine" onclick="setTool('shape', 'line')">üìè</button>
        <select id="shapeSelect" class="shape-select" onchange="setTool('shape', this.value)">
            <option value="" disabled selected>üìê H√¨nh</option>
            <option value="rect">Vu√¥ng/CN</option>
            <option value="circle">‚ö™ Tr√≤n</option>
            <option value="triangle">üî∫ Tam gi√°c</option>
            <option value="axis">H·ªá tr·ª•c Oxy</option>
            <option value="cube">üì¶ H·ªôp</option>
            <option value="sphere">‚öΩ C·∫ßu</option>
            <option value="cylinder">üõ¢Ô∏è Tr·ª•</option>
            <option value="cone">üç¶ N√≥n</option>
        </select>

        <div style="width: 1px; height: 25px; background: #ccc; margin: 0 5px;"></div>

        <button class="btn" id="btnHand" onclick="setTool('hand')" title="Di chuy·ªÉn">üñêÔ∏è</button>
        <button class="btn" onclick="clearInk()" style="color: #c0392b;">‚ùå</button>

        <div class="color-group">
            <div class="color-btn active" style="background: #e74c3c;" onclick="setColor('#e74c3c', this)"></div>
            <div class="color-btn" style="background: #2980b9;" onclick="setColor('#2980b9', this)"></div>
            <div class="color-btn" style="background: #f1c40f;" onclick="setColor('#f1c40f', this)"></div>
            <div class="color-btn" style="background: #2c3e50;" onclick="setColor('#2c3e50', this)"></div>
        </div>
    </div>

    <div id="mainContainer">
        <div style="margin-top: 50%; color: #bbb; font-size: 16px;">
            <b>B·∫¢NG D·∫†Y v4.1 (MOBILE)</b><br>
            <i>Ch·∫ø ƒë·ªô tr∆∞·ª£t ngang/d·ªçc</i><br><br>
            B·∫•m <b>üìÇ</b> ho·∫∑c <b>üîó</b> ƒë·ªÉ m·ªü file.
        </div>
    </div>
</div>

<script>
    let currentTool = 'pen';
    let currentShapeType = 'line'; 
    let currentColor = '#e74c3c';
    let isDrawing = false;
    let startX = 0, startY = 0;
    let snapshot; 

    function toggleFullScreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => { alert(`L·ªói: ${err.message}`); });
        } else {
            if (document.exitFullscreen) document.exitFullscreen();
        }
    }

    function setTool(tool, shapeType = null) {
        currentTool = tool;
        if (shapeType) currentShapeType = shapeType;
        document.querySelectorAll('.toolbar .btn').forEach(b => b.classList.remove('active'));
        
        if(tool === 'pen') document.getElementById('btnPen').classList.add('active');
        if(tool === 'highlighter') document.getElementById('btnHighlighter').classList.add('active');
        if(tool === 'eraser') document.getElementById('btnEraser').classList.add('active');
        if(tool === 'hand') document.getElementById('btnHand').classList.add('active');
        
        if(tool === 'shape') {
            if (shapeType === 'line') document.getElementById('btnLine').classList.add('active');
            else {
                document.getElementById('shapeSelect').style.borderColor = '#2980b9';
                document.getElementById('shapeSelect').style.color = '#2980b9';
            }
        } else {
             document.getElementById('shapeSelect').style.borderColor = '#ccc';
             document.getElementById('shapeSelect').style.color = '#2c3e50';
             document.getElementById('shapeSelect').value = ""; 
        }

        // Logic chuy·ªÉn ch·∫ø ƒë·ªô V·∫Ω <-> Tay
        if (tool === 'hand') {
            document.body.classList.remove('drawing-mode');
            document.body.classList.add('hand-mode');
        } else {
            document.body.classList.add('drawing-mode');
            document.body.classList.remove('hand-mode');
        }
    }

    function setColor(color, element) {
        currentColor = color;
        document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
        element.classList.add('active');
        if (currentTool === 'eraser' || currentTool === 'hand') setTool('pen'); 
    }

    function clearInk() {
        if(confirm("X√≥a m·ª±c trang n√†y?")) {
            document.querySelectorAll('.draw-canvas').forEach(canvas => {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            });
        }
    }

    document.getElementById('pdfInput').onchange = function(e) {
        const file = e.target.files[0];
        if (file) loadPdfData(file.arrayBuffer());
    };

    function loadPdfFromPrompt() {
        const url = prompt("D√°n ƒë∆∞·ªùng link PDF:");
        if (url) {
            document.getElementById('mainContainer').innerHTML = '<div style="color:white; margin-top:50px;">‚è≥ ƒêang t·∫£i...</div>';
            fetch(url)
                .then(response => {
                    if (!response.ok) throw new Error("L·ªói t·∫£i link");
                    return response.arrayBuffer();
                })
                .then(data => loadPdfData(Promise.resolve(data)))
                .catch(err => {
                    alert("L·ªói t·∫£i Link: " + err.message);
                    document.getElementById('mainContainer').innerHTML = '';
                });
        }
    }

    async function loadPdfData(dataPromise) {
        const container = document.getElementById('mainContainer');
        container.innerHTML = '<div style="color:white; margin-top:50px;">‚è≥ ƒêang x·ª≠ l√Ω...</div>';

        try {
            const pdfData = await dataPromise;
            const pdf = await pdfjsLib.getDocument(pdfData).promise;
            container.innerHTML = ''; 

            for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                const page = await pdf.getPage(pageNum);
                // LOGIC SCALE M·ªöI CHO ƒêI·ªÜN THO·∫†I
                // Kh√¥ng √©p v·ª´a chi·ªÅu ngang m√†n h√¨nh n·ªØa, m√† ƒë·∫£m b·∫£o ch·ªØ ƒë·ªß to ƒë·ªÉ ƒë·ªçc
                const viewportRaw = page.getViewport({ scale: 1 });
                
                // N·∫øu m√†n h√¨nh nh·ªè (ƒëi·ªán tho·∫°i), √©p scale t·ªëi thi·ªÉu l√† 0.6 (ho·∫∑c l·ªõn h∆°n t√πy √Ω) 
                // ƒë·ªÉ kh√¥ng b·ªã b√© qu√°. N·∫øu m√†n h√¨nh to th√¨ fit theo chi·ªÅu r·ªông container.
                let scale = container.clientWidth / viewportRaw.width;
                if (scale < 0.6) scale = 0.6; // Scale t·ªëi thi·ªÉu
                if (scale > 1.5) scale = 1.5; // Scale t·ªëi ƒëa
                
                const viewport = page.getViewport({ scale: scale });

                const wrapper = document.createElement('div');
                wrapper.className = 'page-wrapper';
                wrapper.style.width = viewport.width + 'px';
                wrapper.style.height = viewport.height + 'px';

                const pdfCanvas = document.createElement('canvas');
                pdfCanvas.className = 'pdf-canvas';
                pdfCanvas.width = viewport.width;
                pdfCanvas.height = viewport.height;
                const pdfCtx = pdfCanvas.getContext('2d');
                page.render({ canvasContext: pdfCtx, viewport: viewport });

                const drawCanvas = document.createElement('canvas');
                drawCanvas.className = 'draw-canvas';
                drawCanvas.width = viewport.width;
                drawCanvas.height = viewport.height;

                setupDrawing(drawCanvas);

                wrapper.appendChild(pdfCanvas);
                wrapper.appendChild(drawCanvas);
                container.appendChild(wrapper);
            }
        } catch (error) {
            alert("L·ªói hi·ªÉn th·ªã PDF: " + error.message);
        }
    }

    // --- DRAWING ENGINE (TOUCH SUPPORT) ---
    function setupDrawing(canvas) {
        const ctx = canvas.getContext('2d');
        
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX; clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX; clientY = e.clientY;
            }
            return { x: clientX - rect.left, y: clientY - rect.top };
        }

        function startDraw(e) {
            if (currentTool === 'hand') return; 
            // Ch·ªâ ch·∫∑n s·ª± ki·ªán m·∫∑c ƒë·ªãnh (cu·ªôn) khi KH√îNG ph·∫£i ch·∫ø ƒë·ªô Tay
            // V√† ch·∫∑n lu√¥n ƒë·ªÉ ƒë·∫£m b·∫£o n√©t v·∫Ω kh√¥ng b·ªã ng·∫Øt qu√£ng
            if (e.cancelable) e.preventDefault(); 

            isDrawing = true;
            const pos = getPos(e);
            startX = pos.x; startY = pos.y;
            
            if (currentTool === 'shape') {
                snapshot = ctx.getImageData(0, 0, canvas.width, canvas.height);
            } else {
                ctx.beginPath();
                ctx.moveTo(startX, startY);
            }
        }

        function moveDraw(e) {
            if (!isDrawing || currentTool === 'hand') return;
            if (e.cancelable) e.preventDefault(); 

            const pos = getPos(e);
            ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            ctx.setLineDash([]); 

            if (currentTool === 'pen') {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = currentColor; ctx.lineWidth = 2;
                ctx.lineTo(pos.x, pos.y); ctx.stroke();
            } else if (currentTool === 'highlighter') {
                ctx.globalCompositeOperation = 'multiply';
                ctx.strokeStyle = currentColor; ctx.lineWidth = 25;
                ctx.lineTo(pos.x, pos.y); ctx.stroke();
                ctx.globalCompositeOperation = 'source-over';
            } else if (currentTool === 'eraser') {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.lineWidth = 30;
                ctx.lineTo(pos.x, pos.y); ctx.stroke();
                ctx.globalCompositeOperation = 'source-over';
            } else if (currentTool === 'shape') {
                ctx.putImageData(snapshot, 0, 0); 
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = currentColor; ctx.lineWidth = 2;
                drawGeometry(ctx, startX, startY, pos.x, pos.y, currentShapeType);
            }
        }

        function endDraw(e) { isDrawing = false; }

        canvas.addEventListener('mousedown', startDraw);
        canvas.addEventListener('touchstart', startDraw, { passive: false });
        canvas.addEventListener('mousemove', moveDraw);
        canvas.addEventListener('touchmove', moveDraw, { passive: false });
        canvas.addEventListener('mouseup', endDraw);
        canvas.addEventListener('touchend', endDraw);
        canvas.addEventListener('mouseleave', endDraw);
    }

    // --- GEOMETRY & WEB (GI·ªÆ NGUY√äN) ---
    function drawGeometry(ctx, x1, y1, x2, y2, type) {
        const w = x2 - x1; const h = y2 - y1; ctx.beginPath();
        if (type === 'dashed') ctx.setLineDash([10, 8]); else ctx.setLineDash([]);
        if (type === 'line' || type === 'dashed') { ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); } 
        else if (type === 'rect') { ctx.rect(x1, y1, w, h); } 
        else if (type === 'circle') { let r = Math.sqrt(w*w + h*h); ctx.arc(x1, y1, r, 0, 2 * Math.PI); }
        else if (type === 'triangle') { ctx.moveTo(x1 + w/2, y1); ctx.lineTo(x1, y1 + h); ctx.lineTo(x1 + w, y1 + h); ctx.closePath(); }
        else if (type === 'axis') {
            ctx.moveTo(x1, y1 - h); ctx.lineTo(x1, y1 + h);
            ctx.moveTo(x1, y1 - h); ctx.lineTo(x1 - 5, y1 - h + 10); ctx.moveTo(x1, y1 - h); ctx.lineTo(x1 + 5, y1 - h + 10);
            ctx.moveTo(x1 - w, y1); ctx.lineTo(x1 + w, y1);
            ctx.moveTo(x1 + w, y1); ctx.lineTo(x1 + w - 10, y1 - 5); ctx.moveTo(x1 + w, y1); ctx.lineTo(x1 + w - 10, y1 + 5);
        }
        else if (type === 'cube') {
            const d = w / 3; ctx.rect(x1, y1, w, h); ctx.rect(x1 + d, y1 - d, w, h); 
            ctx.moveTo(x1, y1); ctx.lineTo(x1 + d, y1 - d); ctx.moveTo(x1 + w, y1); ctx.lineTo(x1 + w + d, y1 - d);
            ctx.moveTo(x1, y1 + h); ctx.lineTo(x1 + d, y1 + h - d); ctx.moveTo(x1 + w, y1 + h); ctx.lineTo(x1 + w + d, y1 + h - d);
        }
        else if (type === 'sphere') {
            let r = Math.abs(w); ctx.arc(x1 + r, y1 + r, r, 0, 2*Math.PI); ctx.moveTo(x1 + 2*r, y1 + r); ctx.ellipse(x1 + r, y1 + r, r, r/4, 0, 0, 2*Math.PI);
        }
        else if (type === 'cylinder') {
            const rx = w/2; const ry = w/6; 
            ctx.moveTo(x1 + w, y1); ctx.ellipse(x1 + rx, y1, rx, ry, 0, 0, 2*Math.PI);
            ctx.moveTo(x1 + w, y1 + h); ctx.ellipse(x1 + rx, y1 + h, rx, ry, 0, 0, Math.PI); 
            ctx.moveTo(x1, y1); ctx.lineTo(x1, y1 + h); ctx.moveTo(x1 + w, y1); ctx.lineTo(x1 + w, y1 + h);
            ctx.stroke(); ctx.beginPath(); ctx.setLineDash([5, 5]); ctx.ellipse(x1 + rx, y1 + h, rx, ry, 0, Math.PI, 2*Math.PI);
        }
        else if (type === 'cone') {
            const rx = w/2; const ry = w/6;
            ctx.moveTo(x1, y1 + h); ctx.lineTo(x1 + rx, y1); ctx.lineTo(x1 + w, y1 + h);
            ctx.moveTo(x1 + w, y1 + h); ctx.ellipse(x1 + rx, y1 + h, rx, ry, 0, 0, Math.PI);
            ctx.stroke(); ctx.beginPath(); ctx.setLineDash([5, 5]); ctx.ellipse(x1 + rx, y1 + h, rx, ry, 0, Math.PI, 2*Math.PI);
        }
        ctx.stroke(); ctx.setLineDash([]); 
    }

    function addWebsite() {
        let url = prompt("Nh·∫≠p Link Web:", "https://desmos.com/calculator");
        if (!url) return;
        if (!url.startsWith('http')) url = 'https://' + url;
        const win = document.createElement('div'); win.className = 'web-window';
        const header = document.createElement('div'); header.className = 'web-header'; header.innerHTML = `<span>${url}</span>`;
        const btnClose = document.createElement('button'); btnClose.innerText = '‚úï'; btnClose.onclick = () => win.remove();
        header.appendChild(btnClose);
        const content = document.createElement('div'); content.className = 'web-content';
        const iframe = document.createElement('iframe'); iframe.src = url;
        const overlay = document.createElement('canvas'); overlay.className = 'web-overlay';
        new ResizeObserver(() => { overlay.width = content.offsetWidth; overlay.height = content.offsetHeight; }).observe(content);
        setupDrawing(overlay);
        content.appendChild(iframe); content.appendChild(overlay);
        win.appendChild(header); win.appendChild(content); document.body.appendChild(win);
        makeDraggable(win, header);
    }

    function makeDraggable(element, handle) {
        let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; handle.onmousedown = dragMouseDown; handle.ontouchstart = dragMouseDown;
        function dragMouseDown(e) {
            if(e.cancelable) e.preventDefault(); 
            if(e.touches) { pos3 = e.touches[0].clientX; pos4 = e.touches[0].clientY; } else { pos3 = e.clientX; pos4 = e.clientY; }
            document.onmouseup = closeDragElement; document.ontouchend = closeDragElement;
            document.onmousemove = elementDrag; document.ontouchmove = elementDrag;
        }
        function elementDrag(e) {
            e.preventDefault();
            let clientX = e.touches ? e.touches[0].clientX : e.clientX;
            let clientY = e.touches ? e.touches[0].clientY : e.clientY;
            pos1 = pos3 - clientX; pos2 = pos4 - clientY; pos3 = clientX; pos4 = clientY;
            element.style.top = (element.offsetTop - pos2) + "px"; element.style.left = (element.offsetLeft - pos1) + "px";
        }
        function closeDragElement() { document.onmouseup = null; document.onmousemove = null; document.ontouchend = null; document.ontouchmove = null; }
    }
</script>
</body>
</html>