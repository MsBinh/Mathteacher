<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>B·∫¢NG D·∫†Y v18.1 (3D FIX)</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';</script>
    <script>
        window.MathJax = {
            tex: { inlineMath: [['$', '$']], processEscapes: true },
            svg: { fontCache: 'global' },
            startup: { typeset: false, ready: () => { MathJax.startup.defaultReady(); window.mathJaxReady = true; } }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <style>
        :root { --board-bg: #2c3e50; --toolbar-bg: #34495e; --accent: #2ecc71; --yellow: #f1c40f; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #252526; font-family: 'Segoe UI', sans-serif; user-select: none; touch-action: none; }
        .app-layout { display: flex; flex-direction: column; height: 100vh; }
        
        /* TOOLBAR */
        .toolbar { height: 50px; background: var(--toolbar-bg); padding: 0 5px; display: flex; align-items: center; border-bottom: 1px solid #555; z-index: 300; flex-shrink: 0; }
        .toolbar-scroll { display: flex; gap: 8px; align-items: center; overflow-x: auto; white-space: nowrap; flex: 1; padding-right: 10px; -webkit-overflow-scrolling: touch; scrollbar-width: none; }
        .toolbar-scroll::-webkit-scrollbar { display: none; }
        .btn { padding: 6px 12px; border-radius: 6px; border: 1px solid #555; cursor: pointer; font-weight: bold; color: #fff; background: #444; font-size: 14px; display: flex; align-items: center; flex-shrink: 0; min-height: 36px; }
        .btn:hover { background: #555; }
        .btn.active { background: var(--accent); border-color: var(--accent); }
        .sep { width: 1px; height: 25px; background: #666; margin: 0 4px; flex-shrink: 0; }

        /* MATH TOOLBAR */
        .math-toolbar { height: 40px; background: #2c2c2c; display: flex; align-items: center; padding: 0 10px; gap: 8px; border-bottom: 1px solid #444; overflow-x: auto; z-index: 299; white-space: nowrap; -webkit-overflow-scrolling: touch; flex-shrink: 0; }
        .snippet-btn { padding: 4px 10px; font-size: 14px; background: #3a3a3a; color: #ddd; border: 1px solid #555; border-radius: 4px; cursor: pointer; }
        .snippet-btn:hover { background: var(--accent); color: white; }

        /* B·∫¢NG V·∫º */
        #boardWrapper { flex: 1; position: relative; background-color: #0b6b3a; background-image: linear-gradient(rgba(255,255,255,0.1) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.1) 1px, transparent 1px); background-size: 25px 25px; overflow: auto; cursor: crosshair; touch-action: pan-y; }
        #boardWrapper.drawing-active { touch-action: none; cursor: crosshair; }
        #boardWrapper.hand-active { cursor: grab; }
        #mainCanvas { position: absolute; top: 0; left: 0; z-index: 5; pointer-events: auto; }

        /* ELEMENTS */
        .pasted-image, .pasted-pdf, .pasted-web { position: absolute; z-index: 10; cursor: move; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        .pasted-image:hover, .pasted-pdf:hover, .pasted-web:hover { outline: 2px solid var(--yellow); }
        .pasted-web { background: white; display: flex; flex-direction: column; border: 2px solid #ccc; }
        .web-header { padding: 5px; background: #2c3e50; color: white; cursor: move; font-weight: bold; font-size: 12px; display: flex; justify-content: space-between; flex-shrink: 0;}
        iframe { width: 100%; height: 100%; border: none; display: block;}
        .web-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; }
        .resizer { position: absolute; right: 0; bottom: 0; width: 30px; height: 30px; background: orange; cursor: se-resize; z-index: 100; clip-path: polygon(100% 0, 0 100%, 100% 100%); }

        /* MATH BOX */
        .math-box { position: absolute; min-width: 100px; z-index: 20; background-color: #154c27; border-left: 4px solid var(--yellow); border-radius: 4px; box-shadow: 3px 3px 8px rgba(0,0,0,0.4); color: white; font-family: 'Segoe UI', sans-serif; font-size: 22px; display: flex; flex-direction: column; }
        .math-handle { height: 18px; background: rgba(0,0,0,0.2); cursor: move; border-top-right-radius: 4px; width: 100%; display: flex; justify-content: center; align-items: center; }
        .math-handle::after { content: '::::'; color: #ccc; font-size: 10px; letter-spacing: 2px; margin-top: -4px;}
        .math-content { padding: 10px 15px; outline: none; border: none; white-space: pre-wrap; word-wrap: break-word; user-select: text !important; cursor: text; min-height: 1.5em; line-height: 1.5; }
        .latex-rendered { display: inline-block; vertical-align: baseline; cursor: pointer; padding: 0 2px; border-radius: 4px; user-select: none; }
        .latex-rendered:hover { background: rgba(255,255,255,0.2); outline: 1px dashed var(--yellow); }
        .latex-rendered svg { display: inline-block; fill: currentColor; stroke: currentColor; vertical-align: middle; }

        /* LABEL BOX */
        .label-box { position: absolute; z-index: 30; background: transparent; color: var(--yellow); font-family: 'Segoe UI', sans-serif; font-weight: normal; font-size: 18px; padding: 2px 5px; cursor: move; border: 1px dashed transparent; outline: none; min-width: 20px; user-select: text !important; }
        .label-box:focus { border: 1px dashed var(--yellow); background: rgba(0,0,0,0.2); }

        /* UI PH·ª§ */
        .pagination-bar { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: #333; padding: 5px 15px; border-radius: 20px; display: flex; gap: 10px; align-items: center; z-index: 5000; border: 1px solid #555; white-space: nowrap; }
        #pageIndicator { color: var(--yellow); font-weight: bold; font-size: 14px; }
        #colorStatus { width: 24px; height: 24px; border-radius: 50%; border: 2px solid #fff; margin-left: 5px; cursor: pointer; flex-shrink: 0; }
        .modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 90%; max-width: 320px; background: #333; padding: 20px; border-radius: 8px; display: none; z-index: 6000; color: white; box-shadow: 0 5px 20px rgba(0,0,0,0.5); }
        #studentVideoContainer { position: fixed; bottom: 10px; right: 10px; width: 200px; height: 120px; background: black; border: 2px solid var(--yellow); z-index: 7000; display: none; }
        #loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); background: rgba(0,0,0,0.8); color: white; padding: 15px 30px; border-radius: 8px; display: none; z-index: 9999; }
    </style>
</head>
<body class="drawing-mode">

<div id="loading">‚è≥ ƒêang x·ª≠ l√Ω...</div>

<div class="app-layout">
    <div class="toolbar">
        <div class="toolbar-scroll">
            <button class="btn" onclick="toggleFullScreen()" title="Full M√†n H√¨nh">üñ•Ô∏è</button>
            <strong style="color: var(--accent); margin:0 5px;">GV v18.1</strong>
            <button class="btn" id="btnHand" onclick="setTool('hand')" title="Ch·∫ø ƒë·ªô Cu·ªôn">üñêÔ∏è</button>
            <button class="btn" onclick="undo()">‚Ü©Ô∏è</button>
            <button class="btn" onclick="redo()">‚Ü™Ô∏è</button>
            <div class="sep"></div>
            
            <select id="drawTool" style="padding: 8px; border-radius: 4px; background: #eee; font-weight:bold;" onchange="setTool(this.value)">
                <optgroup label="C∆° b·∫£n">
                    <option value="pen" selected>‚úèÔ∏è Vi·∫øt</option>
                    <option value="highlighter">üñçÔ∏è Nh·ªõ</option>
                    <option value="line">üìè Th·∫≥ng</option>
                    <option value="dashedLine"> -- N√©t ƒë·ª©t</option>
                </optgroup>
                <optgroup label="H√¨nh ph·∫≥ng">
                    <option value="rect">‚¨õ CNh·∫≠t</option>
                    <option value="circle">‚ö™ Tr√≤n</option>
                </optgroup>
                <optgroup label="H√¨nh Kh√¥ng Gian (T·ª± n√©t ƒë·ª©t)">
                    <option value="cube">üì¶ H·ªôp</option>
                    <option value="tri_pyramid">üî∫ Ch√≥p Tam Gi√°c</option>
                    <option value="quad_pyramid">‚¨ú Ch√≥p T·ª© Gi√°c</option>
                    <option value="cone">üç¶ N√≥n</option>
                    <option value="cylinder">üõ¢Ô∏è Tr·ª•</option>
                    <option value="sphere">‚öΩ C·∫ßu</option>
                </optgroup>
            </select>
            
            <div id="colorStatus" onclick="cycleColor()" title="ƒê·ªïi m√†u"></div>
            <button class="btn" id="btnMath" onclick="createCenteredMathBox()" style="color: var(--yellow); margin-left: 5px;">$\Sigma$ Box</button>
            <div class="sep"></div>
            
            <button class="btn" id="btnAnnotate" onclick="toggleAnnotation()" style="background:#e67e22">V·∫Ω ƒê√®</button>
            <button class="btn" style="background:#27ae60" onclick="document.getElementById('imageInput').click()">·∫¢nh</button>
            <button class="btn" style="background:#8e44ad" onclick="addWebsite()">Web</button>
            <button class="btn" style="background:#3498db" onclick="document.getElementById('pdfInput').click()">PDF</button>
            <button class="btn" style="background:var(--accent)" onclick="exportFullPDF()">L∆∞u</button>
            <button class="btn" style="color:#c0392b" onclick="toggleLive()">Live</button>
            <button class="btn" onclick="toggleHelp()">?</button>
        </div>
    </div>

    <div class="math-toolbar">
        <button class="snippet-btn" onmousedown="event.preventDefault()" onclick="insertMath('\\frac{}{}')">Ph√¢n s·ªë</button>
        <button class="snippet-btn" onmousedown="event.preventDefault()" onclick="insertMath('\\sqrt{}')">CƒÉn</button>
        <button class="snippet-btn" onmousedown="event.preventDefault()" onclick="insertMath('^{}')">M≈©</button>
        <button class="snippet-btn" onmousedown="event.preventDefault()" onclick="insertMath('\\begin{cases} \\end{cases}')">H·ªá PT</button>
        <button class="snippet-btn" onmousedown="event.preventDefault()" onclick="insertMath('\\int_{}^{}')">T√≠ch ph√¢n</button>
        <button class="snippet-btn" onmousedown="event.preventDefault()" onclick="insertMath('\\vec{}')">Vecto</button>
        <button class="snippet-btn" onmousedown="event.preventDefault()" onclick="insertMath('\\widehat{}')">G√≥c</button>
        <button class="snippet-btn" onmousedown="event.preventDefault()" onclick="insertMath('\\perp')">Vu√¥ng g√≥c</button>
        <button class="snippet-btn" onmousedown="event.preventDefault()" onclick="insertMath('\\parallel')">Song song</button>
        <button class="snippet-btn" onmousedown="event.preventDefault()" onclick="insertMath('\\in')">Thu·ªôc</button>
        <button class="snippet-btn" onmousedown="event.preventDefault()" onclick="insertMath('^\\circ')">ƒê·ªô</button>
        <button class="snippet-btn" onmousedown="event.preventDefault()" onclick="insertMath('\\Delta')">Tam gi√°c</button>
        <button class="snippet-btn" onmousedown="event.preventDefault()" onclick="insertMath('\\Rightarrow')">Suy ra</button>
        <button class="snippet-btn" onmousedown="event.preventDefault()" onclick="insertMath('\\Leftrightarrow')">T∆∞∆°ng ƒë∆∞∆°ng</button>
        <button class="snippet-btn" onmousedown="event.preventDefault()" onclick="insertMath('\\infty')">V√¥ c·ª±c</button>
    </div>

    <div id="boardWrapper" class="drawing-active" ondblclick="handleDoubleClick(event)">
        <canvas id="mainCanvas"></canvas>
        <div id="welcome" style="position:absolute; top:50px; left:50%; transform:translateX(-50%); color:#ccc; text-align:center; pointer-events:none; font-size:14px;">
            <h2>B·∫¢NG D·∫†Y v18.1</h2>
            <p>Paste ƒë·ªÅ b√†i tho·∫£i m√°i.</p>
            <p>V·∫Ω 3D t·ª± ƒë·ªông n√©t ƒë·ª©t.</p>
        </div>
    </div>

    <div class="pagination-bar">
        <button class="btn" onclick="prevPage()">‚óÄ</button>
        <span id="pageIndicator">1/1</span>
        <button class="btn" onclick="nextPage()">‚ñ∂</button>
        <button class="btn" onclick="addPage()" style="background:var(--accent)">‚ûï</button>
    </div>
    
    <input type="file" id="imageInput" accept="image/*" style="display: none;">
    <input type="file" id="pdfInput" accept=".pdf" style="display: none;">
</div>

<div id="liveModal" class="modal">
    <div style="display:flex; justify-content:space-between; margin-bottom:10px;">
        <strong style="color:#e74c3c">LIVESTREAM</strong><span onclick="toggleLive()" style="cursor:pointer">‚úï</span>
    </div>
    <button class="btn" onclick="startBroadcast()" style="width:100%; background:#e74c3c; margin-bottom:10px; justify-content:center;">üé• Ph√°t (Gi√°o vi√™n)</button>
    <div id="hostInfo" style="display:none; margin-bottom:10px; font-size:12px; color:#ccc; word-break: break-all;">M√£: <b id="myId" style="color:white">...</b> <button onclick="copyId()" class="btn" style="display:inline-block; padding:2px 5px; margin-left:5px">Copy</button></div>
    <input type="text" id="remoteId" placeholder="Nh·∫≠p m√£..." style="width:100%; padding:8px; margin-bottom:5px; box-sizing: border-box;">
    <button class="btn" onclick="joinBroadcast()" style="width:100%; background:#3498db; justify-content:center;">üëÄ Xem</button>
</div>

<div id="helpModal" class="modal">
    <div style="display:flex; justify-content:space-between; margin-bottom:10px;">
        <strong style="color:#f1c40f">H∆Ø·ªöNG D·∫™N</strong><span onclick="toggleHelp()" style="cursor:pointer">‚úï</span>
    </div>
    <ul style="padding-left: 20px; margin: 0;">
        <li><b>üñêÔ∏è B√†n tay:</b> Cu·ªôn b·∫£ng.</li>
        <li><b>V·∫Ω ƒê√®:</b> B·∫≠t ƒë·ªÉ khoanh PDF.</li>
        <li><b>3D:</b> N√©t ƒë·ª©t t·ª± ƒë·ªông.</li>
        <li><b>Ctrl+D:</b> T√™n ƒë·ªânh.</li>
    </ul>
</div>

<div id="studentVideoContainer"><video id="studentVideo" autoplay playsinline style="width:100%; height:100%"></video><button onclick="this.parentElement.style.display='none'" style="position:absolute; top:0; right:0; background:red; color:white; border:none; padding:5px;">‚úï</button></div>

<script>
    const canvas = document.getElementById('mainCanvas'); 
    const ctx = canvas.getContext('2d');
    const wrapper = document.getElementById('boardWrapper');
    const colorStatus = document.getElementById('colorStatus');
    const drawToolSelect = document.getElementById('drawTool');

    let isDrawing = false, points = [], snapshot;
    let currentColor = '#ffffff';
    let currentTool = 'pen'; 
    let activeMathBox = null;
    let peer = null, localStream = null;
    let mouseX = 0, mouseY = 0; 

    const BOARD_HEIGHT = 3000;
    let pages = [{ canvasData: null, history: [], historyStep: -1 }];
    let currentPage = 0;
    let history = []; let historyStep = -1;

    function init() {
        canvas.width = wrapper.offsetWidth; 
        canvas.height = BOARD_HEIGHT; 
        ctx.strokeStyle = currentColor; ctx.lineWidth = 2.5; 
        ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        colorStatus.style.background = currentColor;
        updateToolState();
    }
    window.onload = init; 
    window.onresize = () => {
        const img = ctx.getImageData(0,0,canvas.width, canvas.height);
        canvas.width = wrapper.offsetWidth;
        ctx.putImageData(img, 0, 0);
        ctx.strokeStyle = currentColor; ctx.lineWidth = 2.5; ctx.lineCap = 'round';
    };
    wrapper.addEventListener('mousemove', (e) => { mouseX = e.clientX; mouseY = e.clientY; });

    // --- TOOL MANAGEMENT ---
    function setTool(toolName) {
        if(toolName === 'hand') {
            currentTool = 'hand';
            document.getElementById('btnHand').classList.add('active');
        } else {
            currentTool = toolName;
            document.getElementById('btnHand').classList.remove('active');
            if(drawToolSelect.value !== toolName) drawToolSelect.value = toolName;
        }
        updateToolState();
    }

    function updateToolState() {
        if (currentTool === 'hand') {
            wrapper.classList.remove('drawing-active');
            wrapper.classList.add('hand-active');
        } else {
            wrapper.classList.add('drawing-active'); 
            wrapper.classList.remove('hand-active');
        }
    }

    // --- COLOR ---
    const colorPalette = ['#ffffff', '#ff4757', '#ffeb3b', '#3498db', '#2ecc71'];
    let colorIndex = 0;
    function cycleColor() { colorIndex = (colorIndex + 1) % colorPalette.length; updateColor(colorPalette[colorIndex]); }
    function updateColor(color) { currentColor = color; ctx.strokeStyle = color; colorStatus.style.background = color; if(activeMathBox) { activeMathBox.style.color = color; activeMathBox.querySelectorAll('svg').forEach(s => { s.style.fill=color; s.style.color=color; }); } }

    // --- MATH BOX ---
    function handleDoubleClick(e) { if (e.target === canvas) createMathBox(e.offsetX, e.offsetY); }
    function createCenteredMathBox() { createMathBox(wrapper.offsetWidth/2 - 100, wrapper.scrollTop + 200); }

    function createMathBox(x, y) {
        const box = document.createElement('div'); box.className = 'math-box';
        box.style.left = x + 'px'; box.style.top = y + 'px'; box.style.color = currentColor;
        box.dataset.page = currentPage;
        const handle = document.createElement('div'); handle.className = 'math-handle'; box.appendChild(handle);
        const content = document.createElement('div'); content.className = 'math-content'; content.contentEditable = "true"; content.spellcheck = false;
        box.appendChild(content); wrapper.appendChild(box);

        content.addEventListener('paste', (e) => {
            e.preventDefault(); const text = (e.clipboardData || window.clipboardData).getData('text');
            document.execCommand("insertText", false, text);
            setTimeout(() => { content.normalize(); if ((content.innerText.match(/\$/g) || []).length % 2 === 0) processMath(content); }, 10);
        });
        content.addEventListener('input', (e) => { if (!window.mathJaxReady) return; if ((content.innerText.match(/\$/g) || []).length % 2 === 0) { content.normalize(); processMath(content); } });
        content.addEventListener('keydown', e => { if(e.ctrlKey) { if(e.key==='r') { content.normalize(); processMath(content); } if(e.key==='x') { if(confirm('X√≥a?')) box.remove(); } } });
        content.addEventListener('focus', () => activeMathBox = box);
        content.addEventListener('blur', () => { if(window.mathJaxReady){ content.normalize(); processMath(content); } activeMathBox = null; });
        content.focus(); makeElementDraggable(box, handle);
    }

    // --- LABEL BOX ---
    function createLabelBox(x, y) {
        const box = document.createElement('div'); box.className = 'label-box';
        box.contentEditable = "true"; box.spellcheck = false; box.dataset.page = currentPage; box.innerText = "A"; 
        const rect = wrapper.getBoundingClientRect(); 
        let finalX = x - rect.left; let finalY = y - rect.top + wrapper.scrollTop; 
        if(finalX < 0) finalX = 10; if(finalY < 0) finalY = 10;
        box.style.left = finalX + 'px'; box.style.top = finalY + 'px';
        wrapper.appendChild(box); makeElementDraggable(box, box);
        setTimeout(() => { box.focus(); document.execCommand('selectAll', false, null); }, 10);
    }
    window.addEventListener('keydown', (e) => { if ((e.ctrlKey || e.metaKey) && (e.key === 'd' || e.key === 'D')) { e.preventDefault(); createLabelBox(mouseX, mouseY); } });

    async function processMath(contentDiv) {
        if (!window.mathJaxReady) return;
        const walker = document.createTreeWalker(contentDiv, NodeFilter.SHOW_TEXT, null, false);
        let node;
        while (node = walker.nextNode()) {
            const match = /\$([^$]+)\$/.exec(node.nodeValue);
            if (match) {
                const full=match[0], latex=match[1];
                if(!latex.trim()) continue;
                const span = document.createElement('span'); span.className = 'latex-rendered'; span.contentEditable = "false";
                try {
                    const mj = MathJax.tex2svg(latex); span.appendChild(mj);
                    const svg = mj.querySelector('svg'); if(svg) { svg.style.fill=currentColor; svg.style.color=currentColor; }
                    span.onclick = e => { e.stopPropagation(); span.parentNode.replaceChild(document.createTextNode(full), span); contentDiv.focus(); };
                } catch(e) { span.textContent=full; }
                const r = document.createRange(); r.setStart(node, match.index); r.setEnd(node, match.index + full.length);
                r.deleteContents(); r.insertNode(span);
                const s = window.getSelection(); r.setStartAfter(span); r.collapse(true); s.removeAllRanges(); s.addRange(r);
                return;
            }
        }
    }

    function insertMath(code) {
        if (!activeMathBox) { createCenteredMathBox(); setTimeout(() => insertMath(code), 50); return; }
        const content = activeMathBox.querySelector('.math-content'); content.focus();
        const sel = window.getSelection();
        if (sel.rangeCount) {
            const range = sel.getRangeAt(0); range.deleteContents();
            const node = document.createTextNode(code); range.insertNode(node);
            const cursorOffset = code.includes('{}') ? code.indexOf('{}') + 1 : code.length;
            range.setStart(node, cursorOffset); range.setEnd(node, cursorOffset);
            sel.removeAllRanges(); sel.addRange(range);
        }
    }

    // --- DRAWING ENGINE (FIXED COORDS & 3D) ---
    function getPointerPos(e) {
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return { x: clientX - rect.left, y: clientY - rect.top };
    }

    function startDraw(e) {
        if (currentTool === 'hand') return; 
        if (isAnnotationMode && !canDrawAnnotation) return;
        if(e.cancelable) e.preventDefault(); 
        
        isDrawing = true;
        points = [getPointerPos(e)];
        snapshot = ctx.getImageData(0, 0, canvas.width, canvas.height);
        ctx.beginPath(); ctx.moveTo(points[0].x, points[0].y);
    }

    function moveDraw(e) {
        if (!isDrawing) return;
        if(e.cancelable) e.preventDefault();

        const cur = getPointerPos(e);
        ctx.putImageData(snapshot, 0, 0);

        if (currentTool === 'pen' || currentTool === 'highlighter') {
            ctx.save();
            if (currentTool === 'highlighter') { ctx.globalAlpha=0.3; ctx.lineWidth=20; ctx.strokeStyle="yellow"; ctx.lineCap="butt"; }
            else { ctx.lineWidth=2.5; ctx.strokeStyle=currentColor; }
            points.push(cur); ctx.beginPath(); ctx.moveTo(points[0].x, points[0].y);
            for (let i=1; i<points.length-2; i++) {
                const xc = (points[i].x + points[i+1].x)/2, yc = (points[i].y + points[i+1].y)/2;
                ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
            }
            if(points.length>2) ctx.quadraticCurveTo(points[points.length-2].x, points[points.length-2].y, points[points.length-1].x, points[points.length-1].y);
            ctx.stroke(); ctx.restore();
        } else {
            // Shapes
            if (currentTool === 'dashedLine') { ctx.save(); ctx.setLineDash([8, 8]); ctx.beginPath(); ctx.moveTo(points[0].x, points[0].y); ctx.lineTo(cur.x, cur.y); ctx.stroke(); ctx.restore(); }
            else {
                ctx.beginPath();
                if (currentTool==='line') { ctx.moveTo(points[0].x, points[0].y); ctx.lineTo(cur.x, cur.y); }
                else if (currentTool==='rect') ctx.rect(points[0].x, points[0].y, cur.x-points[0].x, cur.y-points[0].y);
                else if (currentTool==='circle') { let r=Math.sqrt((cur.x-points[0].x)**2 + (cur.y-points[0].y)**2); ctx.arc(points[0].x, points[0].y, r, 0, 2*Math.PI); }
                
                // G·ªåI H√ÄM V·∫º 3D
                else if (currentTool==='cube') drawCube3D(points[0].x, points[0].y, cur.x, cur.y);
                else if (currentTool==='tri_pyramid') drawTriPyramid3D(points[0].x, points[0].y, cur.x, cur.y);
                else if (currentTool==='quad_pyramid') drawQuadPyramid3D(points[0].x, points[0].y, cur.x, cur.y);
                else if (currentTool==='cone') drawCone3D(points[0].x, points[0].y, cur.x, cur.y);
                else if (currentTool==='cylinder') drawCylinder3D(points[0].x, points[0].y, cur.x, cur.y);
                else if (currentTool==='sphere') drawSphere3D(points[0].x, points[0].y, cur.x, cur.y);
                
                ctx.stroke();
            }
        }
    }

    function endDraw() { if(isDrawing) { isDrawing=false; saveHistory(); } }

    canvas.addEventListener('mousedown', startDraw); canvas.addEventListener('mousemove', moveDraw); canvas.addEventListener('mouseup', endDraw);
    canvas.addEventListener('touchstart', startDraw, {passive: false}); canvas.addEventListener('touchmove', moveDraw, {passive: false}); canvas.addEventListener('touchend', endDraw);

    // --- 3D FUNCTIONS (SEPARATE DASHED/SOLID) ---
    function drawTriPyramid3D(x1, y1, x2, y2) {
        const S = {x: x1, y: y1}, width = x2 - x1, height = y2 - y1;
        const B = {x: x1 - width, y: y1 + height}, C = {x: x1 + width, y: y1 + height}, A = {x: x1 - width * 0.3, y: y1 + height - height * 0.3};
        
        ctx.beginPath(); ctx.setLineDash([8, 8]); // N√©t ƒë·ª©t
        ctx.moveTo(S.x, S.y); ctx.lineTo(A.x, A.y); ctx.moveTo(B.x, B.y); ctx.lineTo(A.x, A.y); ctx.lineTo(C.x, C.y); ctx.stroke(); 
        
        ctx.setLineDash([]); ctx.beginPath(); // N√©t li·ªÅn
        ctx.moveTo(S.x, S.y); ctx.lineTo(B.x, B.y); ctx.lineTo(C.x, C.y); ctx.lineTo(S.x, S.y); ctx.stroke();
    }
    
    function drawQuadPyramid3D(x1, y1, x2, y2) {
        const baseW = Math.abs(x2 - x1), baseH = Math.abs(y2 - y1), cx = x1, cy = y2, top = {x: cx, y: y1};
        const p1 = {x: cx - baseW, y: cy + baseH*0.2}, p2 = {x: cx + baseW, y: cy + baseH*0.2}, p3 = {x: cx + baseW*1.3, y: cy - baseH*0.2}, p4 = {x: cx - baseW*0.7, y: cy - baseH*0.2};
        
        ctx.beginPath(); ctx.setLineDash([8, 8]); 
        ctx.moveTo(p1.x, p1.y); ctx.lineTo(p4.x, p4.y); ctx.lineTo(p3.x, p3.y); ctx.moveTo(top.x, top.y); ctx.lineTo(p4.x, p4.y); ctx.stroke();
        
        ctx.setLineDash([]); ctx.beginPath(); 
        ctx.moveTo(top.x, top.y); ctx.lineTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.lineTo(top.x, top.y); ctx.lineTo(p3.x, p3.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
    }
    
    function drawCube3D(x1, y1, x2, y2) {
        const w = x2 - x1, h = y2 - y1, d = w * 0.4;
        
        ctx.beginPath(); ctx.setLineDash([8, 8]); 
        ctx.moveTo(x1, y1+h); ctx.lineTo(x1+d, y1+h-d); ctx.lineTo(x1+d, y1-d); ctx.moveTo(x1+d, y1+h-d); ctx.lineTo(x1+w+d, y1+h-d); ctx.stroke();
        
        ctx.setLineDash([]); ctx.beginPath(); 
        ctx.rect(x1, y1, w, h); ctx.moveTo(x1, y1); ctx.lineTo(x1+d, y1-d); ctx.lineTo(x1+w+d, y1-d); ctx.lineTo(x1+w, y1); ctx.moveTo(x1+w, y1); ctx.lineTo(x1+w+d, y1-d); ctx.lineTo(x1+w+d, y1+h-d); ctx.lineTo(x1+w, y1+h); ctx.stroke();
    }
    
    function drawCylinder3D(x1, y1, x2, y2) {
        const rx = Math.abs(x2-x1)/2, ry=rx*0.3, cx=(x1+x2)/2, tY=Math.min(y1,y2), bY=Math.max(y1,y2);
        
        ctx.beginPath(); ctx.setLineDash([8, 8]); 
        ctx.ellipse(cx, bY, rx, ry, 0, Math.PI, 2*Math.PI); ctx.stroke(); // ƒê√°y sau
        
        ctx.setLineDash([]); ctx.beginPath();
        ctx.ellipse(cx, tY, rx, ry, 0, 0, 2*Math.PI); // ƒê√°y tr√™n
        ctx.moveTo(cx-rx, tY); ctx.lineTo(cx-rx, bY); ctx.moveTo(cx+rx, tY); ctx.lineTo(cx+rx, bY); 
        ctx.ellipse(cx, bY, rx, ry, 0, 0, Math.PI); // ƒê√°y tr∆∞·ªõc
        ctx.stroke();
    }
    
    function drawCone3D(x1, y1, x2, y2) {
        const rx = Math.abs(x2-x1)/2, ry=rx*0.3, cx=(x1+x2)/2, tY=y1, bY=y2;
        
        ctx.beginPath(); ctx.setLineDash([8, 8]); 
        ctx.ellipse(cx, bY, rx, ry, 0, Math.PI, 2*Math.PI); ctx.stroke();
        
        ctx.setLineDash([]); ctx.beginPath();
        ctx.moveTo(cx-rx, bY); ctx.lineTo(cx, tY); ctx.lineTo(cx+rx, bY); 
        ctx.ellipse(cx, bY, rx, ry, 0, 0, Math.PI); ctx.stroke();
    }
    
    function drawSphere3D(x1, y1, x2, y2) {
        const r=Math.sqrt((x2-x1)**2+(y2-y1)**2); 
        
        ctx.beginPath(); ctx.setLineDash([8, 8]); 
        ctx.ellipse(x1, y1, r, r*0.3, 0, Math.PI, 2*Math.PI); ctx.stroke();
        
        ctx.setLineDash([]); ctx.beginPath(); 
        ctx.arc(x1, y1, r, 0, 2*Math.PI); 
        ctx.moveTo(x1+r, y1); ctx.ellipse(x1, y1, r, r*0.3, 0, 0, Math.PI); ctx.stroke();
    }

    // --- OTHER UTILS ---
    function toggleFullScreen() { if(!document.fullscreenElement) document.documentElement.requestFullscreen(); else document.exitFullscreen(); }
    
    let isAnnotationMode = false; let canDrawAnnotation = true; 
    function toggleAnnotation() {
        isAnnotationMode = !isAnnotationMode;
        const btn = document.getElementById('btnAnnotate');
        const els = document.querySelectorAll('.pasted-image, .pasted-pdf, .pasted-web, .math-box');
        if (isAnnotationMode) {
            btn.innerHTML = "üìù V·∫Ω ƒê√®: B·∫¨T"; btn.style.background = "#d35400"; 
            canvas.style.zIndex = 2000; // ƒê∆∞a canvas l√™n tr√™n c√πng
            els.forEach(el => { el.style.pointerEvents = 'none'; el.style.opacity = 0.8; });
        } else {
            btn.innerHTML = "üìù V·∫Ω ƒê√®: T·∫ÆT"; btn.style.background = "#e67e22"; 
            canvas.style.zIndex = 5; // Tr·∫£ v·ªÅ d∆∞·ªõi
            els.forEach(el => { el.style.pointerEvents = 'auto'; el.style.opacity = 1; });
        }
    }

    function updatePageIndicator() { document.getElementById('pageIndicator').innerText = `${currentPage + 1} / ${pages.length}`; }
    function saveCurrentPageState() { pages[currentPage].canvasData = canvas.toDataURL(); pages[currentPage].history = [...history]; pages[currentPage].historyStep = historyStep; }
    function switchPage(index) {
        if(index<0 || index>=pages.length) return;
        saveCurrentPageState(); currentPage = index; const p = pages[currentPage];
        history = [...p.history]; historyStep = p.historyStep;
        ctx.clearRect(0,0,canvas.width, canvas.height);
        if(p.canvasData) { const i=new Image(); i.src=p.canvasData; i.onload=()=>ctx.drawImage(i,0,0); }
        document.querySelectorAll('.pasted-image, .pasted-pdf, .pasted-web, .math-box, .label-box').forEach(el => {
            if(!el.dataset.page) el.dataset.page=0; el.style.display = (parseInt(el.dataset.page)===currentPage) ? 'flex' : 'none';
        });
        updatePageIndicator();
    }
    function nextPage() { if(currentPage<pages.length-1) switchPage(currentPage+1); else if(confirm("Trang m·ªõi?")) addPage(); }
    function prevPage() { switchPage(currentPage-1); }
    function addPage() { saveCurrentPageState(); pages.push({canvasData:null, history:[], historyStep:-1}); switchPage(pages.length-1); }

    function addWebsite() {
        let u=prompt("Link Web:"); if(!u)return; if(!u.startsWith('http'))u='https://'+u;
        const w=document.createElement('div'); w.className='pasted-web'; w.dataset.page=currentPage;
        w.style.left='50px'; w.style.top='50px'; w.style.width='600px'; w.style.height='400px';
        w.innerHTML=`<div class="web-header"><span>üåê ${u}</span><span style="cursor:pointer;color:red" onclick="this.parentElement.parentElement.remove()">‚úï</span></div><div class="web-content" style="flex:1;position:relative"><iframe src="${u}"></iframe><div class="web-overlay"></div></div><div class="resizer"></div>`;
        wrapper.appendChild(w); makeElementDraggable(w, w.querySelector('.web-header')); setupResizer(w);
    }
    
    document.getElementById('imageInput').onchange = e => { if(e.target.files[0]) { const i=document.createElement('img'); i.src=URL.createObjectURL(e.target.files[0]); i.className='pasted-image'; i.dataset.page=currentPage; i.style.left='50px'; i.style.top='50px'; i.style.maxWidth='400px'; i.ondblclick=()=>i.remove(); wrapper.appendChild(i); makeElementDraggable(i, i); } e.target.value=''; };
    document.getElementById('pdfInput').onchange = e => { if(e.target.files[0]) createPDFElement(e.target.files[0]); e.target.value=''; };

    async function createPDFElement(file) {
        const c=document.createElement('div'); c.className='pasted-pdf'; c.dataset.page=currentPage;
        c.style.cssText="position:absolute;left:50px;top:50px;width:60%;height:80%;background:white;border:2px dashed #ccc;display:flex;flex-direction:column; z-index:10;";
        c.innerHTML=`<div class="web-header"><span>üìÑ ${file.name}</span><span style="cursor:pointer;color:red" onclick="this.parentElement.parentElement.remove()">‚úï</span></div><div style="flex:1;overflow-y:auto;position:relative"></div><div class="resizer"></div>`;
        const content=c.children[1]; const pdf=await pdfjsLib.getDocument(URL.createObjectURL(file)).promise;
        for(let i=1;i<=pdf.numPages;i++){ const p=await pdf.getPage(i); const v=p.getViewport({scale:1.5}); const cv=document.createElement('canvas'); cv.width=v.width; cv.height=v.height; cv.style.width="100%"; await p.render({canvasContext:cv.getContext('2d'),viewport:v}).promise; content.appendChild(cv); }
        wrapper.appendChild(c); makeElementDraggable(c, c.querySelector('.web-header')); setupResizer(c);
    }

    function makeElementDraggable(el, handle) {
        let isDrag=false, sx, sy, sl, st;
        handle.addEventListener('mousedown', e => { if(e.target.tagName==='SPAN')return; e.preventDefault(); isDrag=true; sx=e.clientX; sy=e.clientY; sl=el.offsetLeft; st=el.offsetTop; document.addEventListener('mousemove', move); document.addEventListener('mouseup', stop); });
        handle.addEventListener('touchstart', e => { if(e.target.tagName==='SPAN')return; isDrag=true; sx=e.touches[0].clientX; sy=e.touches[0].clientY; sl=el.offsetLeft; st=el.offsetTop; document.addEventListener('touchmove', move, {passive:false}); document.addEventListener('touchend', stop); });
        function move(e) { if(!isDrag)return; const cx=e.type.includes('touch')?e.touches[0].clientX:e.clientX; const cy=e.type.includes('touch')?e.touches[0].clientY:e.clientY; el.style.left=(sl+cx-sx)+'px'; el.style.top=(st+cy-sy)+'px'; if(e.preventDefault)e.preventDefault(); }
        function stop() { isDrag=false; document.removeEventListener('mousemove',move); document.removeEventListener('mouseup',stop); document.removeEventListener('touchmove',move); document.removeEventListener('touchend',stop); }
    }

    function setupResizer(el) {
        const resizer = el.querySelector('.resizer'); if(!resizer) return;
        resizer.addEventListener('mousedown', initResize, false);
        resizer.addEventListener('touchstart', initResize, {passive: false});
        function initResize(e) { e.stopPropagation(); e.preventDefault(); 
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            window.startX = clientX; window.startY = clientY;
            window.startW = el.offsetWidth; window.startH = el.offsetHeight;
            
            if(e.type === 'touchstart') { window.addEventListener('touchmove', resize, {passive:false}); window.addEventListener('touchend', stopResize); }
            else { window.addEventListener('mousemove', resize); window.addEventListener('mouseup', stopResize); }
            const overlay = el.querySelector('.web-overlay'); if(overlay) overlay.style.display='block';
        }
        function resize(e) {
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            el.style.width = (window.startW + clientX - window.startX) + 'px';
            el.style.height = (window.startH + clientY - window.startY) + 'px';
        }
        function stopResize() {
            window.removeEventListener('mousemove', resize); window.removeEventListener('mouseup', stopResize);
            window.removeEventListener('touchmove', resize); window.removeEventListener('touchend', stopResize);
            const overlay = el.querySelector('.web-overlay'); if(overlay) overlay.style.display='none';
        }
    }

    function saveHistory() { if(historyStep<history.length-1)history=history.slice(0,historyStep+1); history.push(canvas.toDataURL()); historyStep++; }
    function undo() { if(historyStep>0){ historyStep--; const i=new Image(); i.src=history[historyStep]; i.onload=()=>{ctx.clearRect(0,0,canvas.width,canvas.height);ctx.drawImage(i,0,0);} } else if(historyStep===0){ historyStep=-1; ctx.clearRect(0,0,canvas.width,canvas.height); } }
    function redo() { if(historyStep<history.length-1){ historyStep++; const i=new Image(); i.src=history[historyStep]; i.onload=()=>{ctx.clearRect(0,0,canvas.width,canvas.height);ctx.drawImage(i,0,0);} } }

    async function exportFullPDF() {
        document.getElementById('loading').style.display='block'; const {jsPDF}=window.jspdf; const pdf=new jsPDF('l','mm','a4'); const W=pdf.internal.pageSize.getWidth(), H=pdf.internal.pageSize.getHeight();
        saveCurrentPageState(); const oldPage=currentPage;
        for(let i=0; i<pages.length; i++) { switchPage(i); await new Promise(r=>setTimeout(r,300)); const c = await html2canvas(wrapper, {scale:1.5, useCORS:true, backgroundColor:'#0b6b3a', ignoreElements:el=>el.classList.contains('pagination-bar')}); if(i>0) pdf.addPage(); pdf.addImage(c.toDataURL('image/jpeg',0.8), 'JPEG',0,0,W,H); }
        pdf.save("BaiGiang.pdf"); switchPage(oldPage); document.getElementById('loading').style.display='none';
    }

    async function startBroadcast() {
        if(peer) return alert("ƒêang ph√°t!");
        try { const s = await navigator.mediaDevices.getDisplayMedia({video:true,audio:false}); const a = await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:true},video:false}); localStream = new MediaStream([s.getVideoTracks()[0], a.getAudioTracks()[0]]); peer = new Peer(); peer.on('open', id => { document.getElementById('hostInfo').style.display='block'; document.getElementById('myId').innerText=id; }); peer.on('call', call => call.answer(localStream)); s.getVideoTracks()[0].onended = () => { if(peer)peer.destroy(); peer=null; document.getElementById('hostInfo').style.display='none'; }; } catch(e) { alert(e.message); }
    }
    function joinBroadcast() { const id=document.getElementById('remoteId').value; if(!id) return; const p = new Peer(); p.on('open', () => { const call = p.call(id, new MediaStream()); call.on('stream', s => { document.getElementById('studentVideoContainer').style.display='block'; document.getElementById('studentVideo').srcObject = s; }); }); }
    function copyId() { navigator.clipboard.writeText(document.getElementById('myId').innerText); }
    function toggleLive(){ let m=document.getElementById('liveModal'); m.style.display=m.style.display==='block'?'none':'block'; }
    function toggleHelp(){ let m=document.getElementById('helpModal'); m.style.display=m.style.display==='block'?'none':'block'; }
</script>
</body>
</html>