<!DOCTYPE html>

<html lang="vi">
<head>
<meta charset="utf-8"/>
<title> L·ªöP TO√ÅN TH·∫¶Y B√åNH </title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<!-- Reveal.js CSS -->
<link href="https://unpkg.com/reveal.js/dist/reveal.css" rel="stylesheet"/>
<link href="https://unpkg.com/reveal.js/dist/theme/black.css" id="theme" rel="stylesheet"/>
<!-- Th√™m v√†o ph·∫ßn head, sau c√°c link CSS hi·ªán c√≥ -->
<script src="https://unpkg.com/reveal.js/dist/reveal.js"></script>
<script src="https://unpkg.com/reveal.js/plugin/notes/notes.js"></script>
<script src="https://unpkg.com/reveal.js/plugin/markdown/markdown.js"></script>
<script src="https://unpkg.com/reveal.js/plugin/highlight/highlight.js"></script>
<script src="https://unpkg.com/reveal.js/plugin/math/math.js"></script>
<link href="https://unpkg.com/reveal.js/plugin/highlight/monokai.css" rel="stylesheet"/>
<!-- MathJax -->
<script>
    MathJax = {
      tex: { 
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']]
      },
      svg: { fontCache: 'global', linebreaks: { automatic: true } },
      chtml: { linebreaks: { automatic: true } }
    };
  </script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="styless.css">
<!-- ===== style chuy√™n ƒë·ªÅ  ===== -->
</head>
<body>
<!-- ===== Thanh ti√™u ƒë·ªÅ c·ªë ƒë·ªãnh ===== -->
<div class="topbar">
<div class="topbar-title">L·ªöP TO√ÅN TH·∫¶Y B√åNH</div>
<div class="clock" id="clock">--:--:--</div>
<button id="toggleMenu">‚ò∞</button>
<!-- ==== Thanh c√¥ng c·ª•: Ch·ªçn ƒë·ªÅ / ƒêƒÉng nh·∫≠p / T√≠nh ƒëi·ªÉm ==== -->
<div class="topbar-controls">
  
<select id="selectExam">
<option value="">-- Ch·ªçn ƒë·ªÅ --</option>
<option value="de1">ƒê·ªÅ 1</option>
<option value="de2">ƒê·ªÅ 2</option>
</select>
<button id="loginBtn">üîë ƒêƒÉng nh·∫≠p</button>
<button id="scoreBtn">üìä T√≠nh ƒëi·ªÉm</button>
</div>

</div>
<div class="reveal">
<div class="slides">
<!-------------B·∫ÆT ƒê·∫¶U N·ªòI DUNG C√ÅC SLIDE-->
<!-- T√äN B√ÄI -->
<section>
<h2>üìò ƒê·ªÄ KI·ªÇM TRA</h2>
<p>M√¥n To√°n - L·ªõp 12</p>
</section>
<section>
<h2>üìò PH·∫¶N  TR·∫ÆC NGHI·ªÜM </h2>
</section>
<!--@@@@-->
<h2>üìò PH·∫¶N  ƒê√öNG SAI (4 C√ÇU) </h2>
<section>
<section>
<div class="question" id="q13">
<p class="question-title"><strong>Question 1.</strong> (THPT Tri·ªáu Quang Ph·ª•c - H∆∞ng Y√™n 2025) Cho ƒë·ªì th·ªã h√†m s·ªë $y=\cos x/\left[-\dfrac{5\pi}{2};\dfrac{5\pi}{2}\right]$ d∆∞·ªõi ƒë√¢y. X√©t t√≠nh ƒë√∫ng sai c·ªßa c√°c ph√°t bi·ªÉu sau:</p>
<div class="options">
<div class="option-row">a) a) H√†m s·ªë ƒë√£ cho ƒë·ªìng bi·∫øn tr√™n c√°c kho·∫£ng $(-\pi;0)$ v√† $(\pi;2\pi)$
          <label><input name="q13a" type="radio" value="True"/> True</label>
<label><input name="q13a" type="radio" value="False"/> False</label>
</div>
<div class="option-row">b) b) Gi√° tr·ªã l·ªõn nh·∫•t, gi√° tr·ªã nh·ªè nh·∫•t c·ªßa h√†m s·ªë l√† $Max y=1; Min y=-1$
          <label><input name="q13b" type="radio" value="True"/> True</label>
<label><input name="q13b" type="radio" value="False"/> False</label>
</div>
<div class="option-row">c) c) H√†m s·ªë ƒë√£ cho l√† h√†m tu·∫ßn ho√†n v·ªõi chu k√¨ $2\pi$
          <label><input name="q13c" type="radio" value="True"/> True</label>
<label><input name="q13c" type="radio" value="False"/> False</label>
</div>
<div class="option-row">d) d) Ph∆∞∆°ng tr√¨nh $\cos x=a$ v·ªõi $0<a<\dfrac{1}{2}$ $\left[-\dfrac{5\pi}{2};\dfrac{5\pi}{2}\right]$="" 4="" <label="" c√≥="" nghi·ªám="" tr√™n="" ƒëo·∫°n=""><input name="q13d" type="radio" value="True"/> True
<label><input name="q13d" type="radio" value="False"/> False</label>
</a<\dfrac{1}{2}$></div>
</div>
<div class="answer-check">
<button onclick="checkTrueFalseAnswer('q13',['True','True','True','False'])">Check</button>
</div>
</div>
</section>
</section>
<section>
<section>
<h2>üìò PH·∫¶N  TR·∫¢ L·ªúI NG·∫ÆN ( 6 C√ÇU) </h2>
<section>
<section>
<div class="question" id="q22">
<p><strong>Question 2</strong>. Bi·∫øt ƒë·ªì th·ªã h√†m s·ªë $y=ax^3+bx^2+cx+d$ c√≥ hai ƒëi·ªÉm c·ª±c tr·ªã $A(1;-7), B(2;-8)$. T√≠nh $y(-1)$.</p>
<div class="answer-check">
<input id="input-q22" placeholder="Enter your answer" type="text"/>
<button onclick="checkShortAnswer('q22','-35')">Check</button>
<span id="icon-q22"></span>
</div>
</div>
</section>
</section>
<!---------------------------------------------------------THE END----------------------------------------------------->
</div>
</div>
<!-- Slide Navigation Menu -->
<div class="slide-menu" id="slideMenu">
<div class="menu-header">
<h3>üìã Danh s√°ch slide</h3>
<button class="close-btn" onclick="closeSlideMenu()">√ó</button>
</div>
<div class="menu-content">
<div class="slide-list" id="slideList">
<!-- Danh s√°ch slide s·∫Ω ƒë∆∞·ª£c t·∫°o t·ª± ƒë·ªông b·∫±ng JavaScript -->
</div>
</div>
</div>
<!-- N√∫t m·ªü menu -->
<button class="menu-toggle" id="menuToggle" onclick="toggleSlideMenu()">üìã</button>
<!-- Canvas -->

<!-- ==== Canvas + Toolbar ==== -->
<canvas id="drawCanvas" style="display:none;"></canvas>
<div class="toolbar" id="drawToolbar" style="display:none;">
<a href="../index.html" title="V·ªÅ trang ch·ªß">
  <button id="homeBtn" style="font-size:22px;">üè†</button>
</a>
<select id="tool">
<option value="pen">‚úèÔ∏è B√∫t</option>
<option value="line">üìè ƒê∆∞·ªùng</option>
<option value="rect">‚¨õ Ch·ªØ nh·∫≠t</option>
<option value="parallelogram">‚ñ± B√¨nh h√†nh</option>
<option value="circle">‚ö™ Tr√≤n</option>
<option value="dashedLineBtn">‚Äì ‚Äì</option>
<option value="ellipseBtn">‚¨≠ Elip</option>
<!-- Th√™m 3 c√¥ng c·ª• m·ªõi -->
<option value="box">üì¶ H·ªôp 3D</option>
<option value="pyramid3">üî∫ Ch√≥p tam gi√°c</option>
<option value="pyramid4">üî≤ Ch√≥p t·ª© gi√°c</option>
<option value="sphere">‚öΩ C·∫ßu</option>
</select>
<input id="draw-width" max="5" min="1" type="range" value="2"/>
<input id="colorPicker" type="color" value="#6b21a8">
<button id="undoBtn" title="Undo">‚Ü©Ô∏è</button>
<button id="clearBtn">üßπ Xo√°</button>
<button id="saveBtn">üíæ L∆∞u</button>
<button id="exitBtn">‚ùå Tho√°t</button>
</input></div>
<script>
/* === SCRIPT V·∫º (b·∫Øt ngu·ªìn t·ª´ b2ds) === */
/* M√¨nh ch·ªâ th√™m: history (undo), v√† 3 case v·∫Ω: box, pyramid3, pyramid4.
   Kh√¥ng s·ª≠a logic v·∫Ω kh√°c. */

const canvas = document.getElementById("drawCanvas");
const ctx = canvas.getContext("2d");
const toggleBtn = document.getElementById("toggleMenu");
const toolbar = document.getElementById("drawToolbar");
const clearBtn = document.getElementById("clearBtn");
const saveBtn = document.getElementById("saveBtn");
const exitBtn = document.getElementById("exitBtn");
const colorPicker = document.getElementById("colorPicker");
const toolSelect = document.getElementById("tool");
const widthPicker = document.getElementById("draw-width");
const undoBtn = document.getElementById("undoBtn");

let lineWidth = 2;
widthPicker.oninput = () => lineWidth = parseInt(widthPicker.value);

let isDrawing = false;
let isDrawMode = false;
let startX = 0, startY = 0, lastX = 0, lastY = 0;
let currentTool = "pen";
let imageBeforeShape;

// HISTORY cho Undo (ho√†n t√°c n√©t g·∫ßn nh·∫•t)
let history = [];

// m∆∞·ª£t h∆°n
ctx.lineJoin = "round";
ctx.lineCap = "round";

// k√≠ch th∆∞·ªõc canvas (ƒë∆°n gi·∫£n, gi·ªØ nguy√™n nh∆∞ b2ds)
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener("resize", resizeCanvas);

// b·∫≠t/t·∫Øt v·∫Ω
toggleBtn.onclick = () => {
  isDrawMode = !isDrawMode;
  if (isDrawMode) {
    canvas.style.display = "block";
    toolbar.style.display = "flex";
    canvas.style.pointerEvents = "auto"; // b·∫≠t t∆∞∆°ng t√°c khi v·∫Ω
  } else {
    canvas.style.display = "none";
    toolbar.style.display = "none";
    canvas.style.pointerEvents = "none";
  }
};

// tho√°t
exitBtn.onclick = () => {
  isDrawMode = false;
  canvas.style.display = "none";
  toolbar.style.display = "none";
  canvas.style.pointerEvents = "none";
};

// ch·ªçn c√¥ng c·ª•
toolSelect.onchange = () => currentTool = toolSelect.value;

// undo: ho√†n t√°c 1 b∆∞·ªõc (n√©t g·∫ßn nh·∫•t)
undoBtn.onclick = () => {
  if (history.length > 0) {
    const last = history.pop();
    try {
      ctx.putImageData(last, 0, 0);
    } catch (e) {
      // n·∫øu putImageData l·ªói do mismatch k√≠ch th∆∞·ªõc, clear v√† ignore
      ctx.clearRect(0,0,canvas.width,canvas.height);
    }
  }
};

// xo√° to√†n b·ªô
clearBtn.onclick = () => ctx.clearRect(0, 0, canvas.width, canvas.height);

// l∆∞u ·∫£nh
saveBtn.onclick = () => {
  const link = document.createElement("a");
  link.download = "ban_ve.png";
  link.href = canvas.toDataURL();
  link.click();
};

// fullscreen button (gi·ªØ nguy√™n)
const fullBtn = document.createElement("button");
fullBtn.textContent = "‚õ∂ Full";
fullBtn.title = "To√†n m√†n h√¨nh";
fullBtn.onclick = () => {
  if (!document.fullscreenElement)
    document.documentElement.requestFullscreen().catch(() => {});
  else
    document.exitFullscreen();
};
toolbar.appendChild(fullBtn);

// l·∫•y v·ªã tr√≠ ch√≠nh x√°c
function getPos(e) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  if (e.touches && e.touches.length > 0)
    return { x: (e.touches[0].clientX - rect.left) * scaleX, y: (e.touches[0].clientY - rect.top) * scaleY };
  return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
}

// b·∫Øt ƒë·∫ßu v·∫Ω
function startDraw(e) {
  if (!isDrawMode) return;
  e.preventDefault();
  const pos = getPos(e);

  // L∆ØU tr·∫°ng th√°i tr∆∞·ªõc khi v·∫Ω (cho Undo: ho√†n t√°c n√©t g·∫ßn nh·∫•t)
  try {
    history.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
  } catch (err) {
    // ignore n·∫øu getImageData l·ªói (v√≠ d·ª• canvas ch∆∞a c√≥ k√≠ch th∆∞·ªõc)
  }

  isDrawing = true;
  startX = lastX = pos.x;
  startY = lastY = pos.y;
  ctx.strokeStyle = colorPicker.value;
  ctx.lineWidth = lineWidth;
  ctx.beginPath();
  ctx.moveTo(startX, startY);
  if (currentTool !== "pen") {
    try { imageBeforeShape = ctx.getImageData(0, 0, canvas.width, canvas.height); } catch(e){ imageBeforeShape = null; }
  } else {
    imageBeforeShape = null;
  }
}

// v·∫Ω khi r√™
function drawMove(e) {
  if (!isDrawing || !isDrawMode) return;
  e.preventDefault();
  const pos = getPos(e);
  ctx.strokeStyle = colorPicker.value;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash([]);

  if (currentTool === "pen") {
    ctx.beginPath();
    ctx.moveTo(lastX, lastY);
    ctx.lineTo(pos.x, pos.y);
    ctx.stroke();
    lastX = pos.x; lastY = pos.y;
  } else {
    // kh√¥i ph·ª•c n·ªÅn tr∆∞·ªõc shape live preview
    if (imageBeforeShape) {
      try { ctx.putImageData(imageBeforeShape, 0, 0); } catch(e){ /* ignore */ }
    } else {
      // n·∫øu kh√¥ng c√≥ imageBeforeShape, x√≥a ph·∫ßn v·∫Ω t·∫°m
      // (ƒë·ªÉ tr√°nh ch·ªìng l·ªõp)
      // ctx.clearRect(0,0,canvas.width,canvas.height);
    }

    switch (currentTool) {
      case "line":
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        break;

      case "dashedLineBtn":
        ctx.setLineDash([8,6]);
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        ctx.setLineDash([]);
        break;

      case "rect":
        ctx.strokeRect(startX, startY, pos.x - startX, pos.y - startY);
        break;

      case "circle":
        const r = Math.hypot(pos.x - startX, pos.y - startY);
        ctx.beginPath();
        ctx.arc(startX, startY, r, 0, Math.PI*2);
        ctx.stroke();
        break;

      case "ellipseBtn":
        ctx.setLineDash([6,4]);
        ctx.beginPath();
        ctx.ellipse(startX, startY, Math.abs(pos.x - startX), Math.abs(pos.y - startY), 0, 0, Math.PI*2);
        ctx.stroke();
        ctx.setLineDash([]);
        break;

      case "sphere":
        const rs = Math.abs(pos.x - startX);
        ctx.beginPath();
        ctx.arc(startX, startY, rs, 0, Math.PI*2);
        ctx.stroke();
        ctx.setLineDash([6,4]);
        ctx.beginPath();
        ctx.ellipse(startX, startY, rs, rs/2, 0, Math.PI, 2 * Math.PI);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.ellipse(startX, startY, rs, rs/2, 0, 0, Math.PI);
        ctx.stroke();
        break;

      case "parallelogram":
        const width = pos.x - startX;
        const height = pos.y - startY;
        const offset = width * 0.3;
        ctx.beginPath();
        ctx.moveTo(startX + offset, startY);
        ctx.lineTo(startX + width + offset, startY);
        ctx.lineTo(startX + width - offset, startY + height);
        ctx.lineTo(startX - offset, startY + height);
        ctx.closePath();
        ctx.stroke();
        break;

      /* ==== TH√äM: BOX (H·ªòP 3D) ==== */
      case "box":
        {
          const w = pos.x - startX;
          const h = pos.y - startY;
          const depth = Math.min(Math.abs(w), Math.abs(h)) * 0.3;
          // front face
          ctx.beginPath();
          ctx.strokeRect(startX, startY, w, h);
          // back face (offset by depth up-left)
          ctx.strokeRect(startX + depth, startY - depth, w, h);
          // connect corners
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(startX + depth, startY - depth);
          ctx.moveTo(startX + w, startY);
          ctx.lineTo(startX + w + depth, startY - depth);
          ctx.moveTo(startX, startY + h);
          ctx.lineTo(startX + depth, startY + h - depth);
          ctx.moveTo(startX + w, startY + h);
          ctx.lineTo(startX + w + depth, startY + h - depth);
          ctx.stroke();
        }
        break;

      /* ==== TH√äM: CH√ìP TAM GI√ÅC (pyramid3) ==== */
      /* ==== C·∫¢I TI·∫æN: CH√ìP TAM GI√ÅC 3D (pyramid3) ==== */
        case "pyramid3": {
          // x√°c ƒë·ªãnh 3 ƒë·ªânh ƒë√°y (tam gi√°c n·∫±m tr√™n m·∫∑t ph·∫≥ng ƒë√°y)
          const baseLeft = { x: startX, y: pos.y };
          const baseRight = { x: pos.x, y: pos.y };
          const baseMid = { x: (startX + pos.x) / 2, y: pos.y - (pos.y - startY) * 0.2 };

          // ƒë·ªânh ch√≥p (cao h∆°n ƒë√°y)
          const apex = { 
            x: (startX + pos.x) / 2, 
            y: startY - Math.abs(pos.y - startY) * 0.7 
          };

          ctx.beginPath();
          ctx.setLineDash([]); // n√©t li·ªÅn

          // v·∫Ω m·∫∑t tr∆∞·ªõc (2 c·∫°nh b√™n + c·∫°nh ƒë√°y tr∆∞·ªõc)
          ctx.moveTo(apex.x, apex.y);
          ctx.lineTo(baseLeft.x, baseLeft.y);
          ctx.lineTo(baseRight.x, baseRight.y);
          ctx.closePath();
          ctx.stroke();

          // v·∫Ω c·∫°nh ph√≠a sau (·∫©n - n√©t ƒë·ª©t)
          ctx.setLineDash([6, 4]);
          ctx.beginPath();
          ctx.moveTo(apex.x, apex.y);
          ctx.lineTo(baseMid.x, baseMid.y);
          ctx.stroke();
          ctx.setLineDash([]);
          break;
        }


      /* ==== TH√äM: CH√ìP T·ª® GI√ÅC (pyramid4) ==== */
      case "pyramid4":
        {
          const w4 = pos.x - startX, h4 = pos.y - startY;
          const apexX = startX + w4 / 2;
          const apexY = startY - h4 / 1.5; // apex above the rectangle
          ctx.beginPath();
          // base rectangle (front)
          ctx.rect(startX, startY, w4, h4);
          ctx.stroke();
          // connect base corners to apex
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(apexX, apexY);
          ctx.moveTo(startX + w4, startY);
          ctx.lineTo(apexX, apexY);
          ctx.moveTo(startX, startY + h4);
          ctx.lineTo(apexX, apexY);
          ctx.moveTo(startX + w4, startY + h4);
          ctx.lineTo(apexX, apexY);
          ctx.stroke();
        }
        break;

      case "pyramid3": // duplicate safe-guard
        break;

      default:
        break;
    }
  }
}

// k·∫øt th√∫c
function endDraw() { isDrawing = false; }

canvas.addEventListener("mousedown", startDraw);
canvas.addEventListener("mousemove", drawMove);
canvas.addEventListener("mouseup", endDraw);
canvas.addEventListener("mouseleave", endDraw);
canvas.addEventListener("touchstart", startDraw, { passive: false });
canvas.addEventListener("touchmove", drawMove, { passive: false });
canvas.addEventListener("touchend", endDraw);
  </script>
<!-- Reveal.js -->
<script src="https://unpkg.com/reveal.js/dist/reveal.js"></script>
<script>
  Reveal.initialize({
  width: "100%",   // üëà chi·ªÅu r·ªông = full tr√¨nh duy·ªát
  height: "100%",  // üëà chi·ªÅu cao = full tr√¨nh duy·ªát
  margin: 0.02,    // kho·∫£ng tr·ªëng xung quanh (0 ‚Üí kh√¥ng vi·ªÅn tr·∫Øng)
  minScale: 0.2,
  maxScale: 2,
  slideNumber: true,
  center: false,
  hash: true,
  // c√°c c·∫•u h√¨nh kh√°c...
 
    hash: true,
    plugins: [RevealMarkdown, RevealHighlight, RevealNotes, RevealMath],
    math: {
        mathjax: 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js',
        config: 'TeX-AMS_HTML-full',
        tex2jax: {
            inlineMath: [['$','$'], ['\\(','\\)']],
            displayMath: [['$$','$$'], ['\\[','\\]']],
            balanceBraces: true,
            processEscapes: true,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
        }
    },
    transition: 'slide',
    backgroundTransition: 'fade',
    controls: true,
    progress: true,
    center: true,
    slideNumber: 'c/t'
});

</script>
<!-- ========== SCRIPT V·∫º - B·∫¢N ƒê√É S·ª¨A ·ªîN ƒê·ªäNH (KH√îNG M·∫§T LOGIC) ========== -->
<!-- ========== K·∫æT TH√öC SCRIPT V·∫º ========== -->
<script>
  // H√†m ph√°t √¢m thanh
  function playSound(src) {
    const audio = new Audio(src);
    audio.play();
  }

  // =====================
  // 1Ô∏è‚É£ TR·∫ÆC NGHI·ªÜM 4 L·ª∞A CH·ªåN
  // =====================
  function showOptionIcon(qid, selected, correct) {
    document.querySelectorAll(`#${qid} .option-icon`).forEach(ic => ic.textContent = "");
    const icon = document.getElementById(`icon-${qid}-${selected}`);
    if (icon) icon.textContent = (selected === correct) ? "‚úÖ" : "‚ùå";
  }

  function checkAnswer(qid, correct) {
    // X√≥a icon c≈©
    document.querySelectorAll(`#${qid} .option-icon`).forEach(el => el.textContent = '');
    
    // L·∫•y l·ª±a ch·ªçn
    const chosen = document.querySelector(`input[name="${qid}"]:checked`);
    if (!chosen) {
      alert("H√£y ch·ªçn m·ªôt ƒë√°p √°n!");
      playSound("../audio/wrong.mp3");
      return;
    }

    const chosenVal = chosen.value;
    const iconId = `icon-${qid}-${chosenVal}`;

    // Hi·ªÉn th·ªã ƒë√∫ng/sai + ph√°t √¢m thanh
    if (chosenVal === correct) {
      document.getElementById(iconId).textContent = '‚úÖ';
      playSound("../audio/correct.mp3");
    } else {
      document.getElementById(iconId).textContent = '‚ùå';
      document.getElementById(`icon-${qid}-${correct}`).textContent = '‚úÖ';
      playSound("../audio/wrong.mp3");
    }
  }

  // =====================
  // 2Ô∏è‚É£ C√ÇU H·ªéI ƒê√öNG / SAI
  // =====================
  
</script>
<script>
function playSound(src){
  try{
    const a = new Audio(src);
    a.volume = 0.9;
    a.play().catch(()=>{/* muted or user gesture required */});
  }catch(e){}
}

/**
 * checkTrueFalseAnswer:
 * - questionId: 'q1'
 * - correctAnswers: either an Array like ['True','False','True','True'] OR a string '["True","False",...]'
 */
function checkTrueFalseAnswer(questionId, correctAnswers){
  // normalize correctAnswers to array of strings
  if(typeof correctAnswers === 'string'){
    try{ correctAnswers = JSON.parse(correctAnswers); }
    catch(e){ 
      // fallback: try to split by comma (robust)
      correctAnswers = correctAnswers.replace(/^\[|\]$/g,'').split(',').map(s=>s.trim().replace(/^["']|["']$/g,'')); 
    }
  }
  if(!Array.isArray(correctAnswers)) return console.warn('Invalid correctAnswers for', questionId);

  const container = document.getElementById(questionId);
  if(!container){ console.warn('No container', questionId); return; }

  const optionRows = container.querySelectorAll(".option-row");
  let allCorrect = true;
  let feedbackHtml = '';

  optionRows.forEach((row, idx) => {
    const radios = row.querySelectorAll("input[type='radio']");
    let selected = null;
    radios.forEach(r => { if (r.checked) selected = r.value; });

    const expected = (correctAnswers[idx] && String(correctAnswers[idx]).toLowerCase().startsWith('t')) ? 'True' : 'False';
    const letter = String.fromCharCode(97 + idx); // a, b, c, d

    if (selected === null) {
      feedbackHtml += `M·ªánh ƒë·ªÅ ${letter}) ‚≠ï Ch∆∞a ch·ªçn<br>`;
      allCorrect = false;
    } else if (selected === expected) {
      feedbackHtml += `M·ªánh ƒë·ªÅ ${letter}) ‚úÖ ƒê√∫ng<br>`;
      // add icon near selected radio (if option-icon exists)
      const icon = row.querySelector('.option-icon');
      if(icon) icon.textContent = '‚úÖ';
    } else {
      feedbackHtml += `M·ªánh ƒë·ªÅ ${letter}) ‚ùå Sai (ch·ªçn ${selected})<br>`;
      const icon = row.querySelector('.option-icon');
      if(icon) icon.textContent = '‚ùå';
      allCorrect = false;
    }
  });

  // render feedback in .answer-check .result (create if missing)
  let resultBox = container.querySelector(".answer-check .result");
  if(!resultBox){
    resultBox = document.createElement('div');
    resultBox.className = 'result';
    resultBox.style.marginTop = '8px';
    resultBox.style.padding = '8px';
    resultBox.style.background = 'rgba(255,255,255,0.06)';
    resultBox.style.borderRadius = '6px';
    container.querySelector(".answer-check").appendChild(resultBox);
  }
  resultBox.innerHTML = feedbackHtml;

  // play sound
  if(allCorrect) playSound('../audio/correct.mp3'); else playSound('../audio/wrong.mp3');
}
</script>
<script>
function checkShortAnswer(qid, correct) {
  const input = document.getElementById(`input-${qid}`);
  const icon = document.getElementById(`icon-${qid}`);
  const resultBox = input?.closest(".answer-check");

  if (!input) return;

  const userAnswer = input.value.trim();

  // T·∫°o v√πng th√¥ng b√°o n·∫øu ch∆∞a c√≥
  let feedback = resultBox.querySelector(".result");
  if (!feedback) {
    feedback = document.createElement("div");
    feedback.className = "result";
    feedback.style.marginTop = "6px";
    feedback.style.padding = "6px";
    feedback.style.borderRadius = "6px";
    feedback.style.fontSize = "0.95em";
    resultBox.appendChild(feedback);
  }

  if (userAnswer === "") {
    icon.textContent = "‚ö†Ô∏è";
    feedback.innerHTML = "‚ùó <b>B√°o th·∫ßy ki·ªÉm tr·ª±c ti·∫øp v√¨ ch∆∞a gi·∫£i.</b>";
    playSound("../audio/wrong.mp3");
    return;
  }

  // So s√°nh kh√¥ng ph√¢n bi·ªát kho·∫£ng tr·∫Øng / ch·ªØ hoa
  if (userAnswer.toLowerCase() === correct.trim().toLowerCase()) {
    icon.textContent = "‚úÖ";
    feedback.innerHTML = "üéØ <b>ƒê√∫ng r·ªìi!</b>";
    playSound("../audio/correct.mp3");
  } else {
    icon.textContent = "‚ùå";
    feedback.innerHTML = `‚ùå Sai r·ªìi. ƒê√°p √°n ƒë√∫ng l√†: <b>${correct}</b>`;
    playSound("../audio/wrong.mp3");
  }
}
</script>
<script>
// Bi·∫øn to√†n c·ª•c
let slideMenu, menuToggle, slideList, menuOverlay;

// Kh·ªüi t·∫°o khi DOM ready
document.addEventListener('DOMContentLoaded', function() {
    slideMenu = document.getElementById('slideMenu');
    menuToggle = document.getElementById('menuToggle');
    slideList = document.getElementById('slideList');
    
    // T·∫°o overlay
    menuOverlay = document.createElement('div');
    menuOverlay.className = 'menu-overlay';
    menuOverlay.onclick = closeSlideMenu;
    document.body.appendChild(menuOverlay);
    
    // T·∫°o danh s√°ch slide
    createSlideList();
    
    // L·∫Øng nghe s·ª± ki·ªán chuy·ªÉn slide
    Reveal.addEventListener('slidechanged', updateActiveSlide);
});

// T·∫°o danh s√°ch slide
function createSlideList() {
    const slides = document.querySelectorAll('.reveal .slides section');
    let html = '';
    
    slides.forEach((slide, index) => {
        const slideTitle = getSlideTitle(slide);
        const isVertical = slide.parentNode.classList.contains('stack');
        
        if (!isVertical) {
            html += `
                <div class="slide-item" data-slide-index="${index}" onclick="goToSlide(${index})">
                    <span class="slide-number">${index + 1}</span>
                    ${slideTitle}
                </div>
            `;
        }
    });
    
    slideList.innerHTML = html;
    updateActiveSlide();
}

// L·∫•y ti√™u ƒë·ªÅ slide
function getSlideTitle(slide) {
    // ∆Øu ti√™n t√¨m h2 ƒë·∫ßu ti√™n
    const h2 = slide.querySelector('h2');
    if (h2) return h2.textContent;
    
    // N·∫øu kh√¥ng c√≥ h2, t√¨m ƒëo·∫°n ƒë·∫ßu ti√™n
    const p = slide.querySelector('p');
    if (p) return p.textContent.substring(0, 30) + '...';
    
    // M·∫∑c ƒë·ªãnh
    return `Slide ${Array.from(slide.parentNode.children).indexOf(slide) + 1}`;
}

// C·∫≠p nh·∫≠t slide ƒëang active
function updateActiveSlide() {
    const currentSlide = Reveal.getCurrentSlide();
    const slides = document.querySelectorAll('.reveal .slides section');
    const currentIndex = Array.from(slides).indexOf(currentSlide);
    
    // C·∫≠p nh·∫≠t active class
    document.querySelectorAll('.slide-item').forEach((item, index) => {
        if (index === currentIndex) {
            item.classList.add('active');
        } else {
            item.classList.remove('active');
        }
    });
}

// Chuy·ªÉn ƒë·∫øn slide c·ª• th·ªÉ
function goToSlide(index) {
    Reveal.slide(index);
    closeSlideMenu();
}

// M·ªü/ƒë√≥ng menu
function toggleSlideMenu() {
    slideMenu.classList.toggle('active');
    menuOverlay.classList.toggle('active');
}

function closeSlideMenu() {
    slideMenu.classList.remove('active');
    menuOverlay.classList.remove('active');
}

// ƒê√≥ng menu b·∫±ng ph√≠m ESC
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        closeSlideMenu();
    }
});
</script>
<script>
function updateClock() {
  const now = new Date();
  const h = String(now.getHours()).padStart(2, '0');
  const m = String(now.getMinutes()).padStart(2, '0');
  const s = String(now.getSeconds()).padStart(2, '0');
  document.getElementById("clock").textContent = `${h}:${m}:${s}`;
}
setInterval(updateClock, 1000);
updateClock(); // ch·∫°y ngay khi t·∫£i trang
</script>
<script>
// === AUTO FIX SLIDE STRUCTURE ===
// M·ª•c ƒë√≠ch: ƒê∆∞a m·ªçi <img> (ho·∫∑c <center><img>...</center>) n·∫±m ngo√†i <section> v√†o slide h·ª£p l·ªá
document.addEventListener("DOMContentLoaded", () => {
  const slides = document.querySelector(".reveal .slides");
  if (!slides) return;

  // T·∫°o slide m·ªõi ch·ª©a node
  const makeSlide = (node) => {
    const sec = document.createElement("section");
    sec.appendChild(node);
    return sec;
  };

  // 1Ô∏è‚É£ Di chuy·ªÉn ·∫£nh ho·∫∑c center ch∆∞a n·∫±m trong slide n√†o v√†o slide m·ªõi
  const imgs = [...document.querySelectorAll(".reveal .slides img")];
  imgs.forEach(img => {
    // Ki·ªÉm tra c√≥ n·∫±m trong slide h·ª£p l·ªá kh√¥ng
    let ancestor = img.closest(".reveal .slides > section");
    if (!ancestor) {
      // N·∫øu n·∫±m trong <center>, di chuy·ªÉn c·∫£ center
      const wrap = img.closest("center") || img;
      slides.appendChild(makeSlide(wrap));
    }
  });

  // 2Ô∏è‚É£ S·ª≠a c√°c <section> b·ªã l·ªìng ho·∫∑c ƒë√≥ng sai
  const badNested = [...slides.querySelectorAll("section section")];
  badNested.forEach(sec => slides.appendChild(sec));

  // 3Ô∏è‚É£ X√≥a c√°c section r·ªóng (ch·ªâ ch·ª©a kho·∫£ng tr·∫Øng)
  [...slides.querySelectorAll("section")].forEach(sec => {
    if (!sec.innerHTML.trim()) sec.remove();
  });

  console.log("‚úÖ Slide structure fixed: images moved into valid slides.");
});
</script>
<!----------------->
<!-- LOGIN MODAL (th√™m v√†o n·∫øu ch∆∞a c√≥) -->
<div id="login-modal" style="display:none; position:fixed; inset:0; z-index:12000; 
     background: rgba(0,0,0,0.5); align-items:center; justify-content:center;">
<div style="background:#fff; color:#000; padding:20px; border-radius:8px; width:340px;">
<h3>ƒêƒÉng nh·∫≠p h·ªçc sinh</h3>
<form id="code-login-form">
<input id="login-code" placeholder="M√£ h·ªçc sinh" required="" style="width:100%;padding:8px;margin:6px 0;" type="text"/>
<input id="student-name" placeholder="H·ªç t√™n (t√πy ch·ªçn)" style="width:100%;padding:8px;margin:6px 0;" type="text"/>
<div style="display:flex;gap:8px;justify-content:flex-end;margin-top:8px;">
<button style="padding:6px 10px;" type="submit">ƒêƒÉng nh·∫≠p</button>
<button id="close-modal" style="padding:6px 10px;" type="button">ƒê√≥ng</button>
</div>
</form>
<div id="auth-status" style="margin-top:8px;color:#333;font-weight:600;"></div>
</div>
</div>
<script type="module">
// N·∫øu ch∆∞a khai b√°o global flag, kh·ªüi t·∫°o
if (typeof window.isScoreCalculated === 'undefined') window.isScoreCalculated = false;

function calculateScore() {
  if (window.isScoreCalculated) return;
  const studentAnswers = {};
  const correctAnswers = {};
  let totalScore = 0;

  document.querySelectorAll('.question').forEach(q => {
    const qid = q.id;
    if (!qid) return;
    const btn = q.querySelector('button[onclick*="check"]');
    const onclickStr = btn ? (btn.getAttribute('onclick') || '') : '';

    if (onclickStr.includes('checkTrueFalseAnswer')) {
      const arrMatch = onclickStr.match(/\[(.*?)\]/);
      if (arrMatch) {
        const arr = arrMatch[1].split(',').map(s => s.replace(/['"\s\[\]]/g, '').trim());
        if (arr.length) correctAnswers[qid] = arr;
      }
    } else if (onclickStr.includes('checkShortAnswer')) {
      const m = onclickStr.match(/checkShortAnswer\(['"]([^'"]+)['"]\s*,\s*['"]([^'"]+)['"]\)/);
      if (m) correctAnswers[m[1]] = m[2];
    } else if (onclickStr.includes('checkAnswer')) {
      const m = onclickStr.match(/checkAnswer\(['"]([^'"]+)['"]\s*,\s*['"]([A-Za-z0-9]+)['"]\)/);
      if (m) correctAnswers[m[1]] = m[2].toString().toUpperCase();
    }
  });

  for (let i = 1; i <= 12; i++) {
    const name = 'q' + i;
    const selected = document.querySelector(`input[name="${name}"]:checked`);
    studentAnswers[name] = selected ? selected.value.trim() : '';
  }

  for (let i = 13; i <= 16; i++) {
    const sub = [];
    ['a','b','c','d'].forEach(letter => {
      const sel = document.querySelector(`input[name="q${i}${letter}"]:checked`);
      sub.push(sel ? sel.value.trim() : '');
    });
    studentAnswers['q' + i] = sub;
  }

  for (let i = 17; i <= 22; i++) {
    const el = document.getElementById(`input-q${i}`);
    studentAnswers['q' + i] = el ? el.value.trim().replace(',', '.') : '';
  }

  document.querySelectorAll('.question').forEach(q => {
    const qid = q.id;
    if (!correctAnswers[qid]) {
      const dataCorrect = q.getAttribute('data-correct');
      if (dataCorrect) {
        try {
          const parsed = JSON.parse(dataCorrect);
          correctAnswers[qid] = parsed;
        } catch (e) {
          correctAnswers[qid] = dataCorrect;
        }
      }
    }
  });

  for (let i = 1; i <= 22; i++) {
    const key = 'q' + i;
    const userAns = studentAnswers[key];
    const corr = correctAnswers[key];
    if (i >= 1 && i <= 12) {
      if (!corr) continue;
      if (userAns && String(userAns).toUpperCase() === String(corr).toUpperCase()) totalScore += 0.25;
    } else if (i >= 13 && i <= 16) {
      if (!Array.isArray(corr) || !Array.isArray(userAns)) continue;
      let correctCount = 0;
      for (let j = 0; j < corr.length && j < userAns.length; j++) {
        const exp = String(corr[j]).toLowerCase();
        const u = String(userAns[j]).toLowerCase();
        if (u && (u === exp || (exp.startsWith('t') && u.startsWith('t')) || (exp.startsWith('ƒë') && u.startsWith('ƒë')))) {
          correctCount++;
        }
      }
      if (correctCount === 1) totalScore += 0.1;
      else if (correctCount === 2) totalScore += 0.25;
      else if (correctCount === 3) totalScore += 0.5;
      else if (correctCount === 4) totalScore += 1;
    } else if (i >= 17 && i <= 22) {
      if (typeof corr === 'undefined') continue;
      const userNum = parseFloat((userAns || '').toString().replace(',', '.'));
      const corrNum = parseFloat((corr || '').toString().replace(',', '.'));
      if (!isNaN(userNum) && !isNaN(corrNum)) {
        if (Math.abs(userNum - corrNum) < 0.001) totalScore += 0.5;
      } else {
        if ((userAns || '').toString().trim().toLowerCase() === (corr || '').toString().trim().toLowerCase()) {
          totalScore += 0.5;
        }
      }
    }
  }

  let box = document.getElementById('score-result');
  if (!box) {
    box = document.createElement('div');
    box.id = 'score-result';
    box.style.cssText = 'position:fixed; bottom:15px; right:15px; background:rgba(0,0,0,0.8); color:#fff; padding:10px 14px; border-radius:8px; z-index:99999; font-size:16px;';
    document.body.appendChild(box);
  }
  box.innerHTML = `üìä T·ªïng ƒëi·ªÉm c·ªßa b·∫°n: <b>${totalScore.toFixed(2)}</b> / 10`;

  try { playSound(totalScore >= 5 ? "../audio/correct.mp3" : "../audio/wrong.mp3"); } catch(e){}
  if (typeof saveAttempt === 'function') {
    saveAttempt(document.title || 'de1', { studentAnswers, correctAnswers }, totalScore.toFixed(2));
  }
  console.log('=== correctAnswers ===', correctAnswers);
  console.log('=== studentAnswers ===', studentAnswers);
  console.log('=== totalScore ===', totalScore);
  window.isScoreCalculated = true;
}

document.getElementById('scoreBtn')?.addEventListener('click', calculateScore);
</script>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getFirestore, collection, addDoc, serverTimestamp, query, where, getDocs } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

// === C·∫§U H√åNH FIREBASE ===
const firebaseConfig = {
  apiKey: "AIzaSyDDACFZgZazMOnjzmGM_lrKswVcsoTFHxA",
  authDomain: "veonline-3bcbf.firebaseapp.com",
  projectId: "veonline-3bcbf",
  storageBucket: "veonline-3bcbf.appspot.com",
  messagingSenderId: "83902304195",
  appId: "1:83902304195:web:2f9ec1ee0c23d6e21bb776"
};
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
window.db = db;
window.currentSessionId = null; // session hi·ªán h√†nh



// === X·ª¨ L√ù ƒêƒÇNG NH·∫¨P ===
const codeForm = document.getElementById('code-login-form');
if (codeForm) {
  codeForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    const code = document.getElementById('login-code').value.trim();
    const name = document.getElementById('student-name').value.trim();

    try {
      const codesRef = collection(db, "codes");
      const q = query(codesRef, where("code", "==", code));
      const querySnapshot = await getDocs(q);

      if (!querySnapshot.empty) {
        localStorage.setItem("studentCode", code);
        localStorage.setItem("studentName", name);
        document.getElementById('login-modal').style.display = 'none';
        alert('‚úÖ ƒêƒÉng nh·∫≠p th√†nh c√¥ng!');
      } else {
        alert('‚ùå M√£ kh√¥ng h·ª£p l·ªá!');
      }
    } catch (err) {
      alert('‚ùå L·ªói: ' + err.message);
    }
  });
}

document.getElementById('loginBtn')?.addEventListener('click', (e) => {
  e.preventDefault();
  const studentCode = localStorage.getItem("studentCode");
  if (studentCode) {
    localStorage.removeItem("studentCode");
    localStorage.removeItem("studentName");
    alert('ƒê√£ ƒëƒÉng xu·∫•t');
  } else {
    document.getElementById('login-modal').style.display = 'flex';
  }
});

document.getElementById('close-modal')?.addEventListener('click', () => {
  document.getElementById('login-modal').style.display = 'none';
});

// === L∆ØU K·∫æT QU·∫¢ L√ÄM B√ÄI (C√ì CHI TI·∫æT) ===

window.saveAttempt = async function saveAttempt(testId, detailsOrScore, maybeScore) {
  const code = localStorage.getItem("studentCode");
  const name = localStorage.getItem("studentName");
  if (!code || !name) {
    alert("‚ö†Ô∏è Vui l√≤ng ƒëƒÉng nh·∫≠p tr∆∞·ªõc khi l∆∞u!");
    return;
  }

  let answers = {};
  let totalScore = 0;

  // Nh·∫≠n d·∫°ng c√°ch g·ªçi
  if (typeof detailsOrScore === "object" && maybeScore !== undefined) {
    // G·ªçi d·∫°ng: saveAttempt(testId, { studentAnswers, correctAnswers }, totalScore)
    answers = detailsOrScore.studentAnswers || {};
    totalScore = parseFloat(maybeScore);
  } else {
    // G·ªçi d·∫°ng: saveAttempt(testId, totalScore)
    totalScore = parseFloat(detailsOrScore);
  }

  try {
    await addDoc(collection(db, "attempts"), {
      code,
      name,
      testId,
      score: totalScore,         // ‚úÖ Ghi r√µ c·ªôt ƒëi·ªÉm t·ªïng k·∫øt
      answers,                   // C√≥ th·ªÉ b·ªè n·∫øu kh√¥ng c·∫ßn chi ti·∫øt
      createdAt: serverTimestamp()
    });
    console.log("‚úÖ ƒê√£ l∆∞u ƒëi·ªÉm:", totalScore);
  } catch (err) {
    console.error("‚ùå L·ªói l∆∞u:", err);
  }
}

// Override checkAnswer, checkTrueFalseAnswer, checkShortAnswer to lock and optionally savePartial
window.checkAnswer = function(qid, correct) {
  // X√≥a icon c≈©
  document.querySelectorAll(`#${qid} .option-icon`).forEach(el => el.textContent = '');

  // L·∫•y l·ª±a ch·ªçn
  const chosen = document.querySelector(`input[name="${qid}"]:checked`);
  if (!chosen) {
    alert("H√£y ch·ªçn m·ªôt ƒë√°p √°n!");
    playSound("../audio/wrong.mp3");
    return;
  }

  const chosenVal = chosen.value;
  const iconId = `icon-${qid}-${chosenVal}`;

  // Hi·ªÉn th·ªã ƒë√∫ng/sai + ph√°t √¢m thanh
  if (chosenVal === correct) {
    const el = document.getElementById(iconId);
    if (el) el.textContent = '‚úÖ';
    playSound("../audio/correct.mp3");
    // kh√≥a l·ª±a ch·ªçn
    document.querySelectorAll(`input[name="${qid}"]`).forEach(el=>el.disabled=true);
    if (isLoggedIn()) {
      try { savePartial(qid, chosenVal, correct, true); } catch(e){}
    }
  } else {
    const el = document.getElementById(iconId);
    if (el) el.textContent = '‚ùå';
    const corrEl = document.getElementById(`icon-${qid}-${correct}`);
    if (corrEl) corrEl.textContent = '‚úÖ';
    playSound("../audio/wrong.mp3");
    document.querySelectorAll(`input[name="${qid}"]`).forEach(el=>el.disabled=true);
    if (isLoggedIn()) {
      try { savePartial(qid, chosenVal, correct, false); } catch(e){}
    }
  }
};

// Override checkTrueFalseAnswer
window.checkTrueFalseAnswer = function(questionId, correctAnswers) {
  if(typeof correctAnswers === 'string'){
    try{ correctAnswers = JSON.parse(correctAnswers); }
    catch(e){ 
      correctAnswers = correctAnswers.replace(/^\[|\]$/g,'').split(',').map(s=>s.trim().replace(/^["']|["']$/g,'')); 
    }
  }
  if(!Array.isArray(correctAnswers)) return console.warn('Invalid correctAnswers for', questionId);

  const container = document.getElementById(questionId);
  if(!container){ console.warn('No container', questionId); return; }

  const optionRows = container.querySelectorAll(".option-row");
  let allCorrect = true;
  let feedbackHtml = '';

  optionRows.forEach((row, idx) => {
    const radios = row.querySelectorAll("input[type='radio']");
    let selected = null;
    radios.forEach(r => { if (r.checked) selected = r.value; });

    const expected = (correctAnswers[idx] && String(correctAnswers[idx]).toLowerCase().startsWith('t')) ? 'True' : 'False';
    const letter = String.fromCharCode(97 + idx); // a, b, c, d

    if (selected === null) {
      feedbackHtml += `M·ªánh ƒë·ªÅ ${letter}) ‚≠ï Ch∆∞a ch·ªçn<br>`;
      allCorrect = false;
    } else if (selected === expected) {
      feedbackHtml += `M·ªánh ƒë·ªÅ ${letter}) ‚úÖ ƒê√∫ng<br>`;
      const icon = row.querySelector('.option-icon');
      if(icon) icon.textContent = '‚úÖ';
    } else {
      feedbackHtml += `M·ªánh ƒë·ªÅ ${letter}) ‚ùå Sai (ch·ªçn ${selected})<br>`;
      const icon = row.querySelector('.option-icon');
      if(icon) icon.textContent = '‚ùå';
      allCorrect = false;
    }
  });

  let resultBox = container.querySelector(".answer-check .result");
  if(!resultBox){
    resultBox = document.createElement('div');
    resultBox.className = 'result';
    resultBox.style.marginTop = '8px';
    resultBox.style.padding = '8px';
    resultBox.style.background = 'rgba(255,255,255,0.06)';
    resultBox.style.borderRadius = '6px';
    container.querySelector(".answer-check").appendChild(resultBox);
  }
  resultBox.innerHTML = feedbackHtml;

  // kh√≥a inputs c·ªßa c√¢u n√†y
  container.querySelectorAll("input[type='radio']").forEach(r=>r.disabled=true);

  // l∆∞u partial t·ª´ng m·ªánh ƒë·ªÅ n·∫øu ƒëƒÉng nh·∫≠p
  if (isLoggedIn()) {
    optionRows.forEach((row, idx) => {
      const sel = row.querySelector("input[type='radio']:checked");
      const user = sel ? sel.value : '';
      const expected = (correctAnswers[idx] && String(correctAnswers[idx]).toLowerCase().startsWith('t')) ? 'True' : 'False';
      try { savePartial(questionId + '_' + idx, user, expected, user === expected); } catch(e){}
    });
  }

  if(allCorrect) playSound('../audio/correct.mp3'); else playSound('../audio/wrong.mp3');
};

// Override checkShortAnswer
window.checkShortAnswer = function(qid, correct) {
  const input = document.getElementById(`input-${qid}`);
  const icon = document.getElementById(`icon-${qid}`);
  const resultBox = input?.closest(".answer-check");

  if (!input) return;

  const userAnswer = input.value.trim();

  // T·∫°o v√πng th√¥ng b√°o n·∫øu ch∆∞a c√≥
  let feedback = resultBox.querySelector(".result");
  if (!feedback) {
    feedback = document.createElement("div");
    feedback.className = "result";
    feedback.style.marginTop = "6px";
    feedback.style.padding = "6px";
    feedback.style.borderRadius = "6px";
    feedback.style.fontSize = "0.95em";
    resultBox.appendChild(feedback);
  }

  if (userAnswer === "") {
    icon.textContent = "‚ö†Ô∏è";
    feedback.innerHTML = "‚ùó <b>B√°o th·∫ßy ki·ªÉm tr·ª±c ti·∫øp v√¨ ch∆∞a gi·∫£i.</b>";
    playSound("../audio/wrong.mp3");
    return;
  }

  if (userAnswer.toLowerCase() === correct.trim().toLowerCase()) {
    icon.textContent = "‚úÖ";
    feedback.innerHTML = "üéØ <b>ƒê√∫ng r·ªìi!</b>";
    input.disabled = true;
    if (isLoggedIn()) {
      try { savePartial(qid, userAnswer, correct, true); }catch(e){}
    }
    playSound("../audio/correct.mp3");
  } else {
    icon.textContent = "‚ùå";
    feedback.innerHTML = `‚ùå Sai r·ªìi. ƒê√°p √°n ƒë√∫ng l√†: <b>${correct}</b>`;
    input.disabled = true;
    if (isLoggedIn()) {
      try { savePartial(qid, userAnswer, correct, false); }catch(e){}
    }
    playSound("../audio/wrong.mp3");
  }
};

// Override calculateScore: only save if logged in
if (typeof window.isScoreCalculated === 'undefined') window.isScoreCalculated = false;
window.calculateScore = function() {
  if (window.isScoreCalculated) return;
  const studentAnswers = {};
  const correctAnswers = {};
  let totalScore = 0;

  // gather correct answers from onclicks or data-correct
  document.querySelectorAll('.question').forEach(q => {
    const qid = q.id;
    if (!qid) return;
    const btn = q.querySelector('button[onclick*="check"]');
    const onclickStr = btn ? (btn.getAttribute('onclick') || '') : '';

    if (onclickStr.includes('checkTrueFalseAnswer')) {
      const arrMatch = onclickStr.match(/\[(.*?)\]/);
      if (arrMatch) {
        const arr = arrMatch[1].split(',').map(s => s.replace(/['"\s\[\]]/g, '').trim());
        if (arr.length) correctAnswers[qid] = arr;
      }
    } else if (onclickStr.includes('checkShortAnswer')) {
      const m = onclickStr.match(/checkShortAnswer\(['"]([^'"]+)['"]\s*,\s*['"]([^'"]+)['"]\)/);
      if (m) correctAnswers[m[1]] = m[2];
    } else if (onclickStr.includes('checkAnswer')) {
      const m = onclickStr.match(/checkAnswer\(['"]([^'"]+)['"]\s*,\s*['"]([A-Za-z0-9]+)['"]\)/);
      if (m) correctAnswers[m[1]] = m[2].toString().toUpperCase();
    }

    // fallback data-correct
    if (!correctAnswers[qid]) {
      const dataCorrect = q.getAttribute('data-correct');
      if (dataCorrect) {
        try { correctAnswers[qid] = JSON.parse(dataCorrect); } catch(e) { correctAnswers[qid] = dataCorrect; }
      }
    }
  });

  for (let i = 1; i <= 12; i++) {
    const name = 'q' + i;
    const selected = document.querySelector(`input[name="${name}"]:checked`);
    studentAnswers[name] = selected ? selected.value.trim() : '';
  }

  for (let i = 13; i <= 16; i++) {
    const sub = [];
    ['a','b','c','d'].forEach(letter => {
      const sel = document.querySelector(`input[name="q${i}${letter}"]:checked`);
      sub.push(sel ? sel.value.trim() : '');
    });
    studentAnswers['q' + i] = sub;
  }

  for (let i = 17; i <= 22; i++) {
    const el = document.getElementById(`input-q${i}`);
    studentAnswers['q' + i] = el ? el.value.trim().replace(',', '.') : '';
  }

  for (let i = 1; i <= 22; i++) {
    const key = 'q' + i;
    const userAns = studentAnswers[key];
    const corr = correctAnswers[key];
    if (i >= 1 && i <= 12) {
      if (!corr) continue;
      if (userAns && String(userAns).toUpperCase() === String(corr).toUpperCase()) totalScore += 0.25;
    } else if (i >= 13 && i <= 16) {
      if (!Array.isArray(corr) || !Array.isArray(userAns)) continue;
      let correctCount = 0;
      for (let j = 0; j < corr.length && j < userAns.length; j++) {
        const exp = String(corr[j]).toLowerCase();
        const u = String(userAns[j]).toLowerCase();
        if (u && (u === exp || (exp.startsWith('t') && u.startsWith('t')) || (exp.startsWith('ƒë') && u.startsWith('ƒë')))) {
          correctCount++;
        }
      }
      if (correctCount === 1) totalScore += 0.1;
      else if (correctCount === 2) totalScore += 0.25;
      else if (correctCount === 3) totalScore += 0.5;
      else if (correctCount === 4) totalScore += 1;
    } else if (i >= 17 && i <= 22) {
      if (typeof corr === 'undefined') continue;
      const userNum = parseFloat((userAns || '').toString().replace(',', '.'));
      const corrNum = parseFloat((corr || '').toString().replace(',', '.'));
      if (!isNaN(userNum) && !isNaN(corrNum)) {
        if (Math.abs(userNum - corrNum) < 0.001) totalScore += 0.5;
      } else {
        if ((userAns || '').toString().trim().toLowerCase() === (corr || '').toString().trim().toLowerCase()) {
          totalScore += 0.5;
        }
      }
    }
  }

  let box = document.getElementById('score-result');
  if (!box) {
    box = document.createElement('div');
    box.id = 'score-result';
    box.style.cssText = 'position:fixed; bottom:15px; right:15px; background:rgba(0,0,0,0.8); color:#fff; padding:10px 14px; border-radius:8px; z-index:99999; font-size:16px;';
    document.body.appendChild(box);
  }
  box.innerHTML = `üìä T·ªïng ƒëi·ªÉm c·ªßa b·∫°n: <b>${totalScore.toFixed(2)}</b> / 10`;

  try { playSound(totalScore >= 5 ? "../audio/correct.mp3" : "../audio/wrong.mp3"); } catch(e){}
  if (isLoggedIn() && typeof saveAttempt === 'function') {
    saveAttempt(document.title || 'de1', { studentAnswers, correctAnswers }, totalScore.toFixed(2));
    box.innerHTML += '<br/><small style="opacity:0.95">‚úÖ K·∫øt qu·∫£ ƒë√£ l∆∞u (t√†i kho·∫£n ƒëƒÉng nh·∫≠p)</small>';
  } else {
    box.innerHTML += '<br/><small style="opacity:0.8">‚ÑπÔ∏è Ch∆∞a ƒëƒÉng nh·∫≠p ‚Äî k·∫øt qu·∫£ ch·ªâ hi·ªÉn th·ªã tr√™n tr√¨nh duy·ªát.</small>';
  }
  console.log('=== correctAnswers ===', correctAnswers);
  console.log('=== studentAnswers ===', studentAnswers);
  console.log('=== totalScore ===', totalScore);
  window.isScoreCalculated = true;
};

document.getElementById('scoreBtn')?.addEventListener('click', () => {
  // reset flag to allow re-calc during testing if desired
  window.isScoreCalculated = false;
  window.calculateScore();
});
</script>
<!-- B·∫£ng theo d√µi h·ªçc sinh real-time -->
<div id="teacher-monitor" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 10px; box-shadow: 0 0 30px rgba(0,0,0,0.5); z-index: 20000; width: 90vw; height: 80vh; overflow: auto;">
    <div style="display: flex; justify-content: between; align-items: center; margin-bottom: 20px;">
        <h3 style="margin: 0;">üìä B·∫£ng theo d√µi h·ªçc sinh - REAL TIME</h3>
        <button onclick="closeMonitor()" style="background: #ff4757; color: white; border: none; padding: 8px 15px; border-radius: 5px; margin-left: auto;">‚úï ƒê√≥ng</button>
    </div>
    
    <div style="margin-bottom: 15px;">
        <strong>M√£ l·ªõp:</strong> <code id="monitor-session-code"></code>
        <span style="margin-left: 20px;">
            <strong>H·ªçc sinh online:</strong> <span id="live-student-count">0</span>
        </span>
    </div>

    <!-- B·ªô l·ªçc v√† t√¨m ki·∫øm -->
    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
        <input type="text" id="search-student" placeholder="üîç T√¨m h·ªçc sinh..." style="padding: 8px; border: 1px solid #ddd; border-radius: 5px; flex: 1;">
        <select id="filter-status" style="padding: 8px; border: 1px solid #ddd; border-radius: 5px;">
            <option value="all">T·∫•t c·∫£ tr·∫°ng th√°i</option>
            <option value="active">ƒêang l√†m b√†i</option>
            <option value="finished">ƒê√£ ho√†n th√†nh</option>
            <option value="not-started">Ch∆∞a b·∫Øt ƒë·∫ßu</option>
        </select>
    </div>

    <!-- B·∫£ng k·∫øt qu·∫£ -->
    <div class="table-container" style="max-height: 60vh; overflow-y: auto;">
        <table style="width: 100%; border-collapse: collapse; font-size: 14px;">
            <thead style="background: #f8f9fa; position: sticky; top: 0;">
                <tr>
                    <th style="padding: 12px; border: 1px solid #dee2e6; text-align: left;">H·ªçc sinh</th>
                    <th style="padding: 12px; border: 1px solid #dee2e6; text-align: center;">Tr·∫°ng th√°i</th>
                    <th style="padding: 12px; border: 1px solid #dee2e6; text-align: center;">ƒêi·ªÉm s·ªë</th>
                    <th style="padding: 12px; border: 1px solid #dee2e6; text-align: center;">Th·ªùi gian</th>
                    <th style="padding: 12px; border: 1px solid #dee2e6; text-align: center;">Chi ti·∫øt</th>
                </tr>
            </thead>
            <tbody id="student-results-body">
                <!-- D·ªØ li·ªáu s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t real-time -->
            </tbody>
        </table>
    </div>

    <!-- Th·ªëng k√™ t·ªïng quan -->
    <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
        <h4 style="margin-top: 0;">üìà Th·ªëng k√™ t·ªïng quan</h4>
        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px;">
            <div style="text-align: center;">
                <div style="font-size: 24px; font-weight: bold; color: #17a2b8;" id="stats-total">0</div>
                <div style="font-size: 12px; color: #6c757d;">T·ªïng s·ªë HS</div>
            </div>
            <div style="text-align: center;">
                <div style="font-size: 24px; font-weight: bold; color: #28a745;" id="stats-completed">0</div>
                <div style="font-size: 12px; color: #6c757d;">ƒê√£ ho√†n th√†nh</div>
            </div>
            <div style="text-align: center;">
                <div style="font-size: 24px; font-weight: bold; color: #ffc107;" id="stats-average">0.0</div>
                <div style="font-size: 12px; color: #6c757d;">ƒêi·ªÉm TB</div>
            </div>
            <div style="text-align: center;">
                <div style="font-size: 24px; font-weight: bold; color: #dc3545;" id="stats-failed">0</div>
                <div style="font-size: 12px; color: #6c757d;">D∆∞·ªõi 5 ƒëi·ªÉm</div>
            </div>
        </div>
    </div>
</div>

<!-- N√∫t m·ªü b·∫£ng theo d√µi (cho gi√°o vi√™n) -->
<button id="toggle-monitor" style="position: fixed; bottom: 20px; left: 20px; background: linear-gradient(135deg, #28a745, #20c997); color: white; border: none; padding: 12px 18px; border-radius: 25px; cursor: pointer; z-index: 9999; font-weight: bold; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
    üëÅÔ∏è Theo d√µi HS
</button>
<!-- === BEGIN: Realtime class + Poll + Interaction features === -->
<!-- CDN Chart.js ƒë·ªÉ v·∫Ω bi·ªÉu ƒë·ªì k·∫øt qu·∫£ realtime -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<!-- UI: n√∫t T∆∞∆°ng t√°c cho h·ªçc sinh (n∆°i n√†o th√≠ch h·ª£p trong body) -->
<!-- B·∫°n c√≥ th·ªÉ ƒë·∫∑t n√∫t n√†y trong topbar ho·∫∑c slide footer -->
<button id="student-interact-btn" style="position:fixed; bottom:20px; right:20px; z-index:9999; padding:10px 14px; border-radius:12px; background:#007bff; color:#fff; border:none;">
  üéÆ T∆∞∆°ng t√°c
</button>

<!-- Poll modal (hi·ªán cho HS khi c√≥ poll) -->
<div id="poll-modal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.5); z-index:22000; align-items:center; justify-content:center;">
  <div style="background:#fff; padding:18px; border-radius:8px; width:90%; max-width:520px;">
    <h3 id="poll-title">Poll</h3>
    <div id="poll-options"></div>
    <div style="margin-top:12px; display:flex; justify-content:space-between;">
      <button id="poll-close-btn" style="padding:8px 12px;">ƒê√≥ng</button>
      <button id="poll-submit-btn" style="padding:8px 12px; background:#28a745; color:#fff;">G·ª≠i</button>
    </div>
  </div>
</div>

<!-- Teacher controls: th√™m v√†o teacher-monitor (m√¨nh d√πng v√πng tr√™n c√πng) -->
<!-- N·∫øu mu·ªën, b·∫°n c√≥ th·ªÉ ƒë·∫∑t ph·∫ßn controls n√†y v√†o teacher-monitor HTML hi·ªán c√≥ -->
<div id="teacher-controls" style="display:none; position:fixed; top:12px; right:20px; z-index:22000; gap:8px;">
  <button id="create-session-btn" style="padding:8px 12px; background:#17a2b8; color:#fff; border:none; border-radius:6px;">üÜî T·∫°o l·ªõp m·ªõi</button>
  <button id="start-poll-btn" style="padding:8px 12px; background:#ffc107; color:#000; border:none; border-radius:6px;">üó≥Ô∏è B·∫Øt ƒë·∫ßu poll</button>
  <button id="view-poll-results-btn" style="padding:8px 12px; background:#6f42c1; color:#fff; border:none; border-radius:6px;">üìà Xem k·∫øt qu·∫£ poll</button>
</div>

<!-- Poll results modal (teacher) -->
<div id="poll-results-modal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.5); z-index:22000; align-items:center; justify-content:center;">
  <div style="background:#fff; padding:18px; border-radius:8px; width:90%; max-width:720px;">
    <h3 id="results-title">K·∫øt qu·∫£ poll</h3>
    <canvas id="pollChart" width="600" height="300"></canvas>
    <div style="margin-top:12px; text-align:right;">
      <button id="results-close-btn" style="padding:8px 12px;">ƒê√≥ng</button>
    </div>
  </div>
</div>

<script type="module">
  import { doc, setDoc, addDoc, collection, onSnapshot, updateDoc, getDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

  // ƒë·∫£m b·∫£o db c√≥ s·∫µn (ƒë∆∞·ª£c expose t·ª´ module Firebase tr∆∞·ªõc ƒë√≥)
  const db = window.db;
  if (!db) console.warn('‚ö†Ô∏è db (Firestore) ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o. H√£y ƒë·∫£m b·∫£o ƒëo·∫°n Firebase initialize ch·∫°y tr∆∞·ªõc ph·∫ßn n√†y.');

  // Global state
  window.currentSessionId = window.currentSessionId || null;
  let activePollId = null;     // poll id hi·ªán ƒëang ch·∫°y
  let pollChart = null;

  // H·ªó tr·ª£ t·∫°o m√£ l·ªõp ng·∫´u nhi√™n (6 k√Ω t·ª±)
  function generateSessionCode(len = 6) {
    const chars = 'ABCDEFGHJKMNPQRSTUVWXYZ23456789';
    let s = '';
    for (let i=0;i<len;i++) s += chars[Math.floor(Math.random()*chars.length)];
    return s;
  }

  // --- Teacher: t·∫°o l·ªõp m·ªõi ---
  document.getElementById('create-session-btn')?.addEventListener('click', async () => {
    if (!db) return alert('Firestore ch∆∞a s·∫µn s√†ng.');
    const code = generateSessionCode(6);
    const sessionRef = doc(collection(db, 'classSessions')); // auto id doc
    const sessionId = sessionRef.id;
    await setDoc(sessionRef, {
      code,
      createdAt: serverTimestamp(),
      teacher: (localStorage.getItem('studentName') || 'Gi√°o vi√™n'),
      slideAt: Reveal.getIndices ? Reveal.getIndices().h : 0,
      activePoll: null
    });
    window.currentSessionId = sessionId;
    document.getElementById('monitor-session-code') && (document.getElementById('monitor-session-code').textContent = code);
    document.getElementById('teacher-controls').style.display = 'flex';
    alert('‚úÖ L·ªõp m·ªõi t·∫°o: ' + code + '\nSession ID: ' + sessionId);
  });

  // --- Student: join b·∫±ng m√£ ---
  async function joinSessionByCode(code) {
    if (!db) return alert('Firestore ch∆∞a s·∫µn s√†ng.');
    const qSnap = await getDoc(doc(db, 'classSessions', code)); // this assumes code==docId (we created doc with random id, so we need another query) 
    // NOTE: our sessions use auto-id docs; better to query by field "code":
    // implement proper query:
    const sessionsCol = collection(db, 'classSessions');
    // find session with field code (fallback if previous getDoc fails)
    // use onSnapshot query for real app; but here we'll do a quick query via getDocs (but we didn't import getDocs in this block).
    alert('Vui l√≤ng d√πng ch·ª©c nƒÉng Join qua m√£ l·ªõp (m√£ l·ªõp ƒë∆∞·ª£c hi·ªÉn th·ªã khi gi√°o vi√™n t·∫°o).');
  }

  // --- Start poll (teacher UI) ---
  document.getElementById('start-poll-btn')?.addEventListener('click', async () => {
    if (!window.currentSessionId) return alert('‚ùó Ch∆∞a c√≥ session. Nh·∫•n "T·∫°o l·ªõp m·ªõi" tr∆∞·ªõc.');
    const pollQuestion = prompt('Nh·∫≠p c√¢u h·ªèi poll (vd: B·∫°n hi·ªÉu slide n√†y kh√¥ng?)');
    if (!pollQuestion) return;
    const rawOptions = prompt('Nh·∫≠p c√°c l·ª±a ch·ªçn c√°ch nhau d·∫•u ph·∫©y (v√≠ d·ª•: R√µ r√†ng, B√¨nh th∆∞·ªùng, Ch∆∞a hi·ªÉu)');
    if (!rawOptions) return;
    const options = rawOptions.split(',').map(s => s.trim()).filter(Boolean);
    const pollRef = await addDoc(collection(db, 'classSessions', window.currentSessionId, 'polls'), {
      question: pollQuestion,
      options,
      counts: options.map(_=>0),
      createdAt: serverTimestamp(),
      active: true
    });
    // set active poll on session doc
    await updateDoc(doc(db, 'classSessions', window.currentSessionId), { activePoll: pollRef.id });
    activePollId = pollRef.id;
    alert('‚úÖ Poll b·∫Øt ƒë·∫ßu ‚Äî h·ªçc sinh c√≥ th·ªÉ tr·∫£ l·ªùi.');
    // start listening to poll updates for teacher results
    listenPollResults(window.currentSessionId, activePollId);
  });

  // --- Student: open poll modal when poll exists ---
  // Listen new activePoll on current session (teacher will set session.activePoll)
  function listenSessionActivePoll(sessionId) {
    if (!db || !sessionId) return;
    const sessionDoc = doc(db, 'classSessions', sessionId);
    onSnapshot(sessionDoc, snap => {
      if (!snap.exists()) return;
      const data = snap.data();
      const pollId = data?.activePoll;
      if (pollId) {
        // show poll to student
        showPollForStudent(sessionId, pollId);
      }
    });
  }

  // Show poll UI for student
  async function showPollForStudent(sessionId, pollId) {
    if (!db) return;
    const pollDocRef = doc(db, 'classSessions', sessionId, 'polls', pollId);
    const unsubscribe = onSnapshot(pollDocRef, snap => {
      if (!snap.exists()) return;
      const poll = snap.data();
      document.getElementById('poll-title').textContent = (poll.question || 'Poll');
      const optionsDiv = document.getElementById('poll-options');
      optionsDiv.innerHTML = '';
      poll.options.forEach((opt, i) => {
        const id = `poll-opt-${i}`;
        optionsDiv.insertAdjacentHTML('beforeend', `
          <div style="margin:8px 0;">
            <label style="display:flex; align-items:center; gap:8px;">
              <input type="radio" name="current-poll" value="${i}" id="${id}"> 
              <span>${opt}</span>
            </label>
          </div>
        `);
      });
      document.getElementById('poll-modal').style.display = 'flex';
    });
    // poll submit handler will use sessionId + pollId to write response
  }

  // Student submit poll
  document.getElementById('poll-submit-btn')?.addEventListener('click', async () => {
    if (!window.currentSessionId) return alert('B·∫°n ch∆∞a v√†o l·ªõp.');
    // find active poll id by reading session doc
    const sessionDoc = await getDoc(doc(db, 'classSessions', window.currentSessionId));
    if (!sessionDoc.exists()) return alert('Kh√¥ng t√¨m th·∫•y session.');
    const pollId = sessionDoc.data().activePoll;
    if (!pollId) return alert('Ch∆∞a c√≥ poll ƒëang m·ªü.');

    const selected = document.querySelector('input[name="current-poll"]:checked');
    if (!selected) return alert('Ch·ªçn 1 l·ª±a ch·ªçn tr∆∞·ªõc khi g·ª≠i.');
    const idx = parseInt(selected.value, 10);

    // write student response as a document in pollResponses subcollection
    const code = localStorage.getItem('studentCode') || ('guest-' + Math.floor(Math.random()*10000));
    try {
      // add response doc
      await addDoc(collection(db, 'classSessions', window.currentSessionId, 'polls', pollId, 'responses'), {
        studentId: code,
        answerIndex: idx,
        createdAt: serverTimestamp()
      });
      // also increment aggregate counter atomically
      const pollRef = doc(db, 'classSessions', window.currentSessionId, 'polls', pollId);
      // naive read-update (for simplicity). In production, use a Cloud Function or transaction.
      const pollSnap = await getDoc(pollRef);
      if (pollSnap.exists()) {
        const pollData = pollSnap.data();
        const counts = pollData.counts || pollData.options.map(_=>0);
        counts[idx] = (counts[idx] || 0) + 1;
        await updateDoc(pollRef, { counts });
      }
      alert('‚úÖ C·∫£m ∆°n! ƒê√£ g·ª≠i c√¢u tr·∫£ l·ªùi.');
      document.getElementById('poll-modal').style.display = 'none';
    } catch (e) {
      console.error(e);
      alert('L·ªói khi g·ª≠i c√¢u tr·∫£ l·ªùi: ' + e.message);
    }
  });

  document.getElementById('poll-close-btn')?.addEventListener('click', () => {
    document.getElementById('poll-modal').style.display = 'none';
  });

  // --- Listen poll results and render Chart (teacher) ---
  async function listenPollResults(sessionId, pollId) {
    if (!db || !sessionId || !pollId) return;
    const pollDocRef = doc(db, 'classSessions', sessionId, 'polls', pollId);
    onSnapshot(pollDocRef, snap => {
      if (!snap.exists()) return;
      const poll = snap.data();
      const labels = poll.options || [];
      const counts = poll.counts || labels.map(_=>0);
      renderPollChart(labels, counts);
    });
    // show results modal to teacher
    document.getElementById('poll-results-modal').style.display = 'flex';
  }

  function renderPollChart(labels, counts) {
    const ctx = document.getElementById('pollChart').getContext('2d');
    if (pollChart) {
      pollChart.data.labels = labels;
      pollChart.data.datasets[0].data = counts;
      pollChart.update();
      return;
    }
    pollChart = new Chart(ctx, {
      type: 'bar',
      data: {
        labels,
        datasets: [{
          label: 'S·ªë l∆∞·ª£t ch·ªçn',
          data: counts,
          backgroundColor: labels.map(()=> 'rgba(54,162,235,0.6)'),
          borderColor: labels.map(()=> 'rgba(54,162,235,1)'),
          borderWidth: 1
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: { y: { beginAtZero: true, precision:0 } }
      }
    });
  }

  document.getElementById('results-close-btn')?.addEventListener('click', () => {
    document.getElementById('poll-results-modal').style.display = 'none';
  });

  // --- Raise hand / Ask question (student) ---
  document.getElementById('student-interact-btn')?.addEventListener('click', () => {
    // open small menu: raise-hand / ask-question
    const choice = prompt('Ch·ªçn: 1 = Gi∆° tay, 2 = ƒê·∫∑t c√¢u h·ªèi');
    if (!choice) return;
    if (!window.currentSessionId) return alert('B·∫°n ch∆∞a v√†o l·ªõp (ch∆∞a c√≥ m√£ session).');
    if (choice === '1') {
      addActivity({ action: 'raise-hand', studentId: localStorage.getItem('studentCode') || 'guest', payload: '' });
      alert('‚úÖ B·∫°n ƒë√£ gi∆° tay.');
    } else if (choice === '2') {
      const q = prompt('Nh·∫≠p c√¢u h·ªèi c·ªßa b·∫°n:');
      if (!q) return;
      addActivity({ action: 'question', studentId: localStorage.getItem('studentCode') || 'guest', payload: q });
      alert('‚úÖ C√¢u h·ªèi ƒë√£ g·ª≠i.');
    } else {
      alert('L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá.');
    }
  });

  // write activity to activities subcollection
  async function addActivity({ action, studentId, payload }) {
    if (!db || !window.currentSessionId) return;
    try {
      await addDoc(collection(db, 'classSessions', window.currentSessionId, 'activities'), {
        studentId,
        action,
        payload: payload || '',
        createdAt: serverTimestamp()
      });
    } catch (e) {
      console.error('L·ªói addActivity', e);
    }
  }

  // --- Listen activities for teacher monitor (existing monitoring code uses activities subcollection) ---
  // ensure setupActivityTracking in your file will be able to get activities from currentSessionId
  // So we also listen for changes on session code mapping (doc) to set currentSessionId if teacher shares code.
  // Utility: find session doc by code (teacher shares code)
  async function findSessionIdByCode(code) {
    if (!db) return null;
    // naive approach: scan sessions (fine for small scale). For large scale, index by code->docId mapping.
    const sessionsCol = collection(db, 'classSessions');
    // we cannot import getDocs here because not imported; for brevity we assume teacher uses created session (so currentSessionId already set)
    return null;
  }

  // --- Startup: if currentSessionId exists, start listeners ---
  if (window.currentSessionId) {
    listenSessionActivePoll(window.currentSessionId);
    // also show teacher controls when teacher logged in (simple heuristic: if localStorage.studentName contains 'Gi√°o vi√™n')
    if ((localStorage.getItem('studentName') || '').toLowerCase().includes('gi√°o')) {
      document.getElementById('teacher-controls').style.display = 'flex';
    }
  }

  // Expose some helpers to window for debugging
  window.createSession = async () => { document.getElementById('create-session-btn').click(); };
  window.startPoll = async () => { document.getElementById('start-poll-btn').click(); };
  window.joinSession = async (sessionId) => { window.currentSessionId = sessionId; listenSessionActivePoll(sessionId); alert('ƒê√£ v√†o session: ' + sessionId); };

</script>
<!-- === END: Realtime class + Poll + Interaction features === -->

<script>
// =====================
// THEO D√ïI H·ªåC SINH REAL-TIME
// =====================
let monitorStudents = new Map();

function setupStudentMonitoring() {
    const monitorBtn = document.getElementById('toggle-monitor');
    if (monitorBtn) {
        monitorBtn.addEventListener('click', toggleMonitor);
    }

    // L·∫Øng nghe k·∫øt qu·∫£ l√†m b√†i real-time
    const attemptsRef = collection(db, 'attempts');
    const q = query(attemptsRef, where('testId', '==', document.title || 'de1'));
    
    onSnapshot(q, (snapshot) => {
        snapshot.docChanges().forEach((change) => {
            const data = change.doc.data();
            const studentId = data.code;
            
            if (change.type === 'added' || change.type === 'modified') {
                // C·∫≠p nh·∫≠t th√¥ng tin h·ªçc sinh
                monitorStudents.set(studentId, {
                    id: studentId,
                    name: data.name || 'Ch∆∞a ƒë·∫∑t t√™n',
                    score: parseFloat(data.score) || 0,
                    status: data.score !== undefined ? 'finished' : 'active',
                    timestamp: data.createdAt?.toDate() || new Date(),
                    answers: data.answers || {},
                    lastActivity: new Date()
                });
            } else if (change.type === 'removed') {
                monitorStudents.delete(studentId);
            }
        });
        
        updateMonitorDisplay();
        updateStatistics();
    });

    // L·∫Øng nghe ho·∫°t ƒë·ªông real-time c·ªßa h·ªçc sinh
    setupActivityTracking();
}

function setupActivityTracking() {
    // Theo d√µi khi h·ªçc sinh t∆∞∆°ng t√°c v·ªõi c√¢u h·ªèi
    const activityRef = collection(db, 'classSessions', currentSessionId, 'activities');
    
    onSnapshot(activityRef, (snapshot) => {
        snapshot.docChanges().forEach((change) => {
            if (change.type === 'added') {
                const data = change.doc.data();
                updateStudentActivity(data.studentId, data.questionId, data.action);
            }
        });
    });
}

function updateStudentActivity(studentId, questionId, action) {
    if (!monitorStudents.has(studentId)) {
        monitorStudents.set(studentId, {
            id: studentId,
            name: 'H·ªçc sinh m·ªõi',
            score: 0,
            status: 'active',
            timestamp: new Date(),
            answers: {},
            lastActivity: new Date(),
            currentQuestion: questionId
        });
    }
    
    const student = monitorStudents.get(studentId);
    student.lastActivity = new Date();
    student.currentQuestion = questionId;
    
    if (action === 'answer') {
        student.answers[questionId] = 'answered';
    }
    
    updateMonitorDisplay();
}

function updateMonitorDisplay() {
    const tbody = document.getElementById('student-results-body');
    if (!tbody) return;
    
    const searchTerm = document.getElementById('search-student')?.value.toLowerCase() || '';
    const filterStatus = document.getElementById('filter-status')?.value || 'all';
    
    let html = '';
    let displayedCount = 0;
    
    monitorStudents.forEach((student) => {
        // L·ªçc theo t√¨m ki·∫øm
        if (searchTerm && !student.name.toLowerCase().includes(searchTerm)) {
            return;
        }
        
        // L·ªçc theo tr·∫°ng th√°i
        if (filterStatus !== 'all' && student.status !== filterStatus) {
            return;
        }
        
        displayedCount++;
        
        const statusBadge = getStatusBadge(student.status);
        const scoreDisplay = student.score > 0 ? student.score.toFixed(2) : '-';
        const timeAgo = getTimeAgo(student.lastActivity);
        
        html += `
            <tr style="border-bottom: 1px solid #dee2e6;">
                <td style="padding: 12px;">
                    <strong>${escapeHtml(student.name)}</strong><br>
                    <small style="color: #6c757d;">ID: ${student.id}</small>
                </td>
                <td style="padding: 12px; text-align: center;">
                    ${statusBadge}
                    ${student.currentQuestion ? `<br><small>ƒêang l√†m: ${student.currentQuestion}</small>` : ''}
                </td>
                <td style="padding: 12px; text-align: center; font-weight: bold; color: ${getScoreColor(student.score)}">
                    ${scoreDisplay}
                </td>
                <td style="padding: 12px; text-align: center;">
                    ${timeAgo}
                </td>
                <td style="padding: 12px; text-align: center;">
                    <button onclick="viewStudentDetails('${student.id}')" style="background: #17a2b8; color: white; border: none; padding: 6px 12px; border-radius: 4px; font-size: 12px; cursor: pointer;">
                        üëÅÔ∏è Chi ti·∫øt
                    </button>
                </td>
            </tr>
        `;
    });
    
    tbody.innerHTML = html || '<tr><td colspan="5" style="text-align: center; padding: 20px; color: #6c757d;">Ch∆∞a c√≥ h·ªçc sinh n√†o tham gia</td></tr>';
    
    // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng h·ªçc sinh online
    document.getElementById('live-student-count').textContent = displayedCount;
}

function updateStatistics() {
    const students = Array.from(monitorStudents.values());
    const total = students.length;
    const completed = students.filter(s => s.status === 'finished').length;
    const average = total > 0 ? students.reduce((sum, s) => sum + (s.score || 0), 0) / total : 0;
    const failed = students.filter(s => s.score < 5).length;
    
    document.getElementById('stats-total').textContent = total;
    document.getElementById('stats-completed').textContent = completed;
    document.getElementById('stats-average').textContent = average.toFixed(1);
    document.getElementById('stats-failed').textContent = failed;
}

function getStatusBadge(status) {
    const badges = {
        'active': '<span style="background: #ffc107; color: #000; padding: 4px 8px; border-radius: 12px; font-size: 12px;">üü° ƒêang l√†m</span>',
        'finished': '<span style="background: #28a745; color: white; padding: 4px 8px; border-radius: 12px; font-size: 12px;">‚úÖ Ho√†n th√†nh</span>',
        'not-started': '<span style="background: #6c757d; color: white; padding: 4px 8px; border-radius: 12px; font-size: 12px;">‚ö´ Ch∆∞a b·∫Øt ƒë·∫ßu</span>'
    };
    return badges[status] || badges['not-started'];
}

function getScoreColor(score) {
    if (score >= 8) return '#28a745';
    if (score >= 5) return '#ffc107';
    return '#dc3545';
}

function getTimeAgo(timestamp) {
    const now = new Date();
    const diffMs = now - timestamp;
    const diffMins = Math.floor(diffMs / 60000);
    
    if (diffMins < 1) return 'V·ª´a xong';
    if (diffMins < 60) return `${diffMins} ph√∫t tr∆∞·ªõc`;
    
    const diffHours = Math.floor(diffMins / 60);
    return `${diffHours} gi·ªù tr∆∞·ªõc`;
}

function toggleMonitor() {
    const monitor = document.getElementById('teacher-monitor');
    if (monitor.style.display === 'none') {
        monitor.style.display = 'block';
        document.getElementById('monitor-session-code').textContent = currentSessionId;
        updateMonitorDisplay();
        updateStatistics();
    } else {
        monitor.style.display = 'none';
    }
}

function closeMonitor() {
    document.getElementById('teacher-monitor').style.display = 'none';
}

function viewStudentDetails(studentId) {
    const student = monitorStudents.get(studentId);
    if (!student) return;
    
    alert(`
Chi ti·∫øt h·ªçc sinh:
üìõ T√™n: ${student.name}
üéØ M√£: ${student.id}
üìä ƒêi·ªÉm: ${student.score || 'Ch∆∞a c√≥'}
üìù Tr·∫°ng th√°i: ${student.status === 'finished' ? 'ƒê√£ ho√†n th√†nh' : 'ƒêang l√†m b√†i'}
‚è∞ Ho·∫°t ƒë·ªông cu·ªëi: ${student.lastActivity.toLocaleTimeString()}

C√¢u h·ªèi ƒë√£ l√†m: ${Object.keys(student.answers).length}
    `);
}

// Th√™m s·ª± ki·ªán t√¨m ki·∫øm v√† l·ªçc
document.addEventListener('DOMContentLoaded', function() {
    // T√¨m ki·∫øm h·ªçc sinh
    const searchInput = document.getElementById('search-student');
    if (searchInput) {
        searchInput.addEventListener('input', updateMonitorDisplay);
    }
    
    // L·ªçc tr·∫°ng th√°i
    const filterSelect = document.getElementById('filter-status');
    if (filterSelect) {
        filterSelect.addEventListener('change', updateMonitorDisplay);
    }
});

// Kh·ªüi t·∫°o monitoring khi trang load
setTimeout(() => {
    setupStudentMonitoring();
}, 2000);

// H√†m escape HTML
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Make functions globally available
window.toggleMonitor = toggleMonitor;
window.closeMonitor = closeMonitor;
window.viewStudentDetails = viewStudentDetails;
</script>
</body>
</html>
