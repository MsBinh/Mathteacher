<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8">
  <title> LỚP TOÁN THẦY BÌNH </title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Reveal.js CSS -->
  <link rel="stylesheet" href="https://unpkg.com/reveal.js/dist/reveal.css">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js/dist/theme/black.css" id="theme">
  <!-- Thêm vào phần head, sau các link CSS hiện có -->
  <script src="https://unpkg.com/reveal.js/dist/reveal.js"></script>
  <script src="https://unpkg.com/reveal.js/plugin/notes/notes.js"></script>
  <script src="https://unpkg.com/reveal.js/plugin/markdown/markdown.js"></script>
  <script src="https://unpkg.com/reveal.js/plugin/highlight/highlight.js"></script>
  <script src="https://unpkg.com/reveal.js/plugin/math/math.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/reveal.js/plugin/highlight/monokai.css">
  <!-- MathJax -->
  <script>
    MathJax = {
      tex: { 
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']]
      },
      svg: { fontCache: 'global', linebreaks: { automatic: true } },
      chtml: { linebreaks: { automatic: true } }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
/* ===== TOÀN BỘ GIAO DIỆN (giữ nguyên từ b2ds) ===== */
.reveal .backgrounds {
  background: linear-gradient(135deg, #fdfdfd 0%, #f6f8fa 100%);
}
.reveal section {
  color: #020a44;
  font-family: "Segoe UI", "Helvetica Neue", Arial, sans-serif;
  font-size: 26px;
  line-height: 1.6;
  text-shadow: none;
  letter-spacing: 0.3px;
  transition: color 0.3s;
}
.reveal .slides section {
  max-width: 100% !important;
  width: 100% !important;
  height: auto;
  background: #ffffff;
  border-radius: 10px;
  box-shadow: 0 0 20px rgba(243, 5, 40, 0.08);
  padding: 20px;
  box-sizing: border-box;
}
.reveal h1, .reveal h2, .reveal h3 {
  color: #004aad;
  font-weight: 700;
  letter-spacing: 0.5px;
}
/* ... (bỏ bớt phần CSS lặp để ngắn gọn; giữ nguyên style chính như bạn có) ... */

/* ===== TOOLBAR VẼ (giữ nguyên) ===== */
#drawCanvas {
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  z-index: 9998;
  touch-action: none;
  pointer-events: none; /* JS sẽ bật pointer-events khi bật chế độ vẽ */
}

.toolbar {
  position: fixed;
  top: 70px;
  left: 10px;
  background: white;
  border-radius: 10px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
  padding: 6px;
  z-index: 10000;
  display: flex;
  flex-direction: column;
  gap: 4px;
  width: 48px;
  align-items: center;
}

.toolbar button,
.toolbar select,
.toolbar input[type="color"],
.toolbar input[type="range"] {
  width: 100%;
  font-size: 10px;
  padding: 2px;
  height: 28px;
  box-sizing: border-box;
}

#toggleMenu {
  position: fixed;
  top: 15px;
  left: 40px;
  z-index: 99999 !important;
  font-size: 22px;
  background: rgba(0,0,0,0.45);
  color: #fff;
  border: none;
  border-radius: 6px;
  padding: 3px 8px;
  cursor: pointer;
}
#toggleMenu:hover {
  background: rgba(255,255,255,0.25);
}

/* Ensure reveal controls & progress visible above canvas */
.reveal .controls,
.reveal .progress,
.reveal .slide-number {
  z-index: 10005 !important;
  pointer-events: auto !important;
}

/* Ensure toolbar stays above controls but below toggleMenu */
#toolbar { z-index: 10010 !important; }
#toggleMenu { z-index: 10030 !important; }

/* (Phần CSS khác của trang giữ nguyên) */
  </style>
</head>

<body>
  <div class="topbar">
    <div class="topbar-title">LỚP TOÁN THẦY BÌNH</div>
    <div class="clock" id="clock">--:--:--</div>
  </div>

  <div class="reveal">
    <div class="slides">
      <section>
        <h2>📘 BÀI 2</h2>
        <p>Môn Toán - Lớp 12</p>
      </section>
      <section>
        <h2>📘 BÀI TẬP TRẮC NGHIỆM</h2>
      </section>
      <!-- Các slide khác giữ nguyên -->
    </div>
  </div>

  <!-- Slide Menu / UI giữ nguyên... -->
  <div id="slideMenu" class="slide-menu">
    <div class="menu-header">
      <h3>📋 Danh sách slide</h3>
      <button onclick="closeSlideMenu()" class="close-btn">×</button>
    </div>
    <div class="menu-content">
      <div id="slideList" class="slide-list"></div>
    </div>
  </div>

  <button id="menuToggle" class="menu-toggle" onclick="toggleSlideMenu()">📋</button>

  <!-- ==== Canvas + Toolbar ==== -->
  <canvas id="drawCanvas" style="display:none;"></canvas>

  <div class="toolbar" id="drawToolbar" style="display:none;">
    <select id="tool">
      <option value="pen">✏️ Bút</option>
      <option value="line">📏 Đường</option>
      <option value="rect">⬛ Chữ nhật</option>
      <option value="parallelogram">▱ Bình hành</option>
      <option value="circle">⚪ Tròn</option>
      <option value="dashedLineBtn">– –</option>
      <option value="ellipseBtn">⬭ Elip</option>
      <!-- Thêm 3 công cụ mới -->
      <option value="box">📦 Hộp 3D</option>
      <option value="pyramid3">🔺 Chóp tam giác</option>
      <option value="pyramid4">🔲 Chóp tứ giác</option>
      <option value="sphere">⚽ Cầu</option>
    </select>
    <input type="range" id="draw-width" min="1" max="5" value="2" />
    <input type="color" id="colorPicker" value="#6b21a8" />
    <button id="undoBtn" title="Undo">↩️</button>
    <button id="clearBtn">🧹 Xoá</button>
    <button id="saveBtn">💾 Lưu</button>
    <button id="exitBtn">❌ Thoát</button>
  </div>

  <button id="toggleMenu">☰</button>

  <script>
/* === SCRIPT VẼ (bắt nguồn từ b2ds) === */
/* Mình chỉ thêm: history (undo), và 3 case vẽ: box, pyramid3, pyramid4.
   Không sửa logic vẽ khác. */

const canvas = document.getElementById("drawCanvas");
const ctx = canvas.getContext("2d");
const toggleBtn = document.getElementById("toggleMenu");
const toolbar = document.getElementById("drawToolbar");
const clearBtn = document.getElementById("clearBtn");
const saveBtn = document.getElementById("saveBtn");
const exitBtn = document.getElementById("exitBtn");
const colorPicker = document.getElementById("colorPicker");
const toolSelect = document.getElementById("tool");
const widthPicker = document.getElementById("draw-width");
const undoBtn = document.getElementById("undoBtn");

let lineWidth = 2;
widthPicker.oninput = () => lineWidth = parseInt(widthPicker.value);

let isDrawing = false;
let isDrawMode = false;
let startX = 0, startY = 0, lastX = 0, lastY = 0;
let currentTool = "pen";
let imageBeforeShape;

// HISTORY cho Undo (hoàn tác nét gần nhất)
let history = [];

// mượt hơn
ctx.lineJoin = "round";
ctx.lineCap = "round";

// kích thước canvas (đơn giản, giữ nguyên như b2ds)
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener("resize", resizeCanvas);

// bật/tắt vẽ
toggleBtn.onclick = () => {
  isDrawMode = !isDrawMode;
  if (isDrawMode) {
    canvas.style.display = "block";
    toolbar.style.display = "flex";
    canvas.style.pointerEvents = "auto"; // bật tương tác khi vẽ
  } else {
    canvas.style.display = "none";
    toolbar.style.display = "none";
    canvas.style.pointerEvents = "none";
  }
};

// thoát
exitBtn.onclick = () => {
  isDrawMode = false;
  canvas.style.display = "none";
  toolbar.style.display = "none";
  canvas.style.pointerEvents = "none";
};

// chọn công cụ
toolSelect.onchange = () => currentTool = toolSelect.value;

// undo: hoàn tác 1 bước (nét gần nhất)
undoBtn.onclick = () => {
  if (history.length > 0) {
    const last = history.pop();
    try {
      ctx.putImageData(last, 0, 0);
    } catch (e) {
      // nếu putImageData lỗi do mismatch kích thước, clear và ignore
      ctx.clearRect(0,0,canvas.width,canvas.height);
    }
  }
};

// xoá toàn bộ
clearBtn.onclick = () => ctx.clearRect(0, 0, canvas.width, canvas.height);

// lưu ảnh
saveBtn.onclick = () => {
  const link = document.createElement("a");
  link.download = "ban_ve.png";
  link.href = canvas.toDataURL();
  link.click();
};

// fullscreen button (giữ nguyên)
const fullBtn = document.createElement("button");
fullBtn.textContent = "⛶ Full";
fullBtn.title = "Toàn màn hình";
fullBtn.onclick = () => {
  if (!document.fullscreenElement)
    document.documentElement.requestFullscreen().catch(() => {});
  else
    document.exitFullscreen();
};
toolbar.appendChild(fullBtn);

// lấy vị trí chính xác
function getPos(e) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  if (e.touches && e.touches.length > 0)
    return { x: (e.touches[0].clientX - rect.left) * scaleX, y: (e.touches[0].clientY - rect.top) * scaleY };
  return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
}

// bắt đầu vẽ
function startDraw(e) {
  if (!isDrawMode) return;
  e.preventDefault();
  const pos = getPos(e);

  // LƯU trạng thái trước khi vẽ (cho Undo: hoàn tác nét gần nhất)
  try {
    history.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
  } catch (err) {
    // ignore nếu getImageData lỗi (ví dụ canvas chưa có kích thước)
  }

  isDrawing = true;
  startX = lastX = pos.x;
  startY = lastY = pos.y;
  ctx.strokeStyle = colorPicker.value;
  ctx.lineWidth = lineWidth;
  ctx.beginPath();
  ctx.moveTo(startX, startY);
  if (currentTool !== "pen") {
    try { imageBeforeShape = ctx.getImageData(0, 0, canvas.width, canvas.height); } catch(e){ imageBeforeShape = null; }
  } else {
    imageBeforeShape = null;
  }
}

// vẽ khi rê
function drawMove(e) {
  if (!isDrawing || !isDrawMode) return;
  e.preventDefault();
  const pos = getPos(e);
  ctx.strokeStyle = colorPicker.value;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash([]);

  if (currentTool === "pen") {
    ctx.beginPath();
    ctx.moveTo(lastX, lastY);
    ctx.lineTo(pos.x, pos.y);
    ctx.stroke();
    lastX = pos.x; lastY = pos.y;
  } else {
    // khôi phục nền trước shape live preview
    if (imageBeforeShape) {
      try { ctx.putImageData(imageBeforeShape, 0, 0); } catch(e){ /* ignore */ }
    } else {
      // nếu không có imageBeforeShape, xóa phần vẽ tạm
      // (để tránh chồng lớp)
      // ctx.clearRect(0,0,canvas.width,canvas.height);
    }

    switch (currentTool) {
      case "line":
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        break;

      case "dashedLineBtn":
        ctx.setLineDash([8,6]);
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        ctx.setLineDash([]);
        break;

      case "rect":
        ctx.strokeRect(startX, startY, pos.x - startX, pos.y - startY);
        break;

      case "circle":
        const r = Math.hypot(pos.x - startX, pos.y - startY);
        ctx.beginPath();
        ctx.arc(startX, startY, r, 0, Math.PI*2);
        ctx.stroke();
        break;

      case "ellipseBtn":
        ctx.setLineDash([6,4]);
        ctx.beginPath();
        ctx.ellipse(startX, startY, Math.abs(pos.x - startX), Math.abs(pos.y - startY), 0, 0, Math.PI*2);
        ctx.stroke();
        ctx.setLineDash([]);
        break;

      case "sphere":
        const rs = Math.abs(pos.x - startX);
        ctx.beginPath();
        ctx.arc(startX, startY, rs, 0, Math.PI*2);
        ctx.stroke();
        ctx.setLineDash([6,4]);
        ctx.beginPath();
        ctx.ellipse(startX, startY, rs, rs/2, 0, Math.PI, 2 * Math.PI);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.ellipse(startX, startY, rs, rs/2, 0, 0, Math.PI);
        ctx.stroke();
        break;

      case "parallelogram":
        const width = pos.x - startX;
        const height = pos.y - startY;
        const offset = width * 0.3;
        ctx.beginPath();
        ctx.moveTo(startX + offset, startY);
        ctx.lineTo(startX + width + offset, startY);
        ctx.lineTo(startX + width - offset, startY + height);
        ctx.lineTo(startX - offset, startY + height);
        ctx.closePath();
        ctx.stroke();
        break;

      /* ==== THÊM: BOX (HỘP 3D) ==== */
      case "box":
        {
          const w = pos.x - startX;
          const h = pos.y - startY;
          const depth = Math.min(Math.abs(w), Math.abs(h)) * 0.3;
          // front face
          ctx.beginPath();
          ctx.strokeRect(startX, startY, w, h);
          // back face (offset by depth up-left)
          ctx.strokeRect(startX + depth, startY - depth, w, h);
          // connect corners
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(startX + depth, startY - depth);
          ctx.moveTo(startX + w, startY);
          ctx.lineTo(startX + w + depth, startY - depth);
          ctx.moveTo(startX, startY + h);
          ctx.lineTo(startX + depth, startY + h - depth);
          ctx.moveTo(startX + w, startY + h);
          ctx.lineTo(startX + w + depth, startY + h - depth);
          ctx.stroke();
        }
        break;

      /* ==== THÊM: CHÓP TAM GIÁC (pyramid3) ==== */
      /* ==== CẢI TIẾN: CHÓP TAM GIÁC 3D (pyramid3) ==== */
        case "pyramid3": {
          // xác định 3 đỉnh đáy (tam giác nằm trên mặt phẳng đáy)
          const baseLeft = { x: startX, y: pos.y };
          const baseRight = { x: pos.x, y: pos.y };
          const baseMid = { x: (startX + pos.x) / 2, y: pos.y - (pos.y - startY) * 0.2 };

          // đỉnh chóp (cao hơn đáy)
          const apex = { 
            x: (startX + pos.x) / 2, 
            y: startY - Math.abs(pos.y - startY) * 0.7 
          };

          ctx.beginPath();
          ctx.setLineDash([]); // nét liền

          // vẽ mặt trước (2 cạnh bên + cạnh đáy trước)
          ctx.moveTo(apex.x, apex.y);
          ctx.lineTo(baseLeft.x, baseLeft.y);
          ctx.lineTo(baseRight.x, baseRight.y);
          ctx.closePath();
          ctx.stroke();

          // vẽ cạnh phía sau (ẩn - nét đứt)
          ctx.setLineDash([6, 4]);
          ctx.beginPath();
          ctx.moveTo(apex.x, apex.y);
          ctx.lineTo(baseMid.x, baseMid.y);
          ctx.stroke();
          ctx.setLineDash([]);
          break;
        }


      /* ==== THÊM: CHÓP TỨ GIÁC (pyramid4) ==== */
      case "pyramid4":
        {
          const w4 = pos.x - startX, h4 = pos.y - startY;
          const apexX = startX + w4 / 2;
          const apexY = startY - h4 / 1.5; // apex above the rectangle
          ctx.beginPath();
          // base rectangle (front)
          ctx.rect(startX, startY, w4, h4);
          ctx.stroke();
          // connect base corners to apex
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(apexX, apexY);
          ctx.moveTo(startX + w4, startY);
          ctx.lineTo(apexX, apexY);
          ctx.moveTo(startX, startY + h4);
          ctx.lineTo(apexX, apexY);
          ctx.moveTo(startX + w4, startY + h4);
          ctx.lineTo(apexX, apexY);
          ctx.stroke();
        }
        break;

      case "pyramid3": // duplicate safe-guard
        break;

      default:
        break;
    }
  }
}

// kết thúc
function endDraw() { isDrawing = false; }

canvas.addEventListener("mousedown", startDraw);
canvas.addEventListener("mousemove", drawMove);
canvas.addEventListener("mouseup", endDraw);
canvas.addEventListener("mouseleave", endDraw);
canvas.addEventListener("touchstart", startDraw, { passive: false });
canvas.addEventListener("touchmove", drawMove, { passive: false });
canvas.addEventListener("touchend", endDraw);
  </script>

  <!-- Reveal.js init (giữ nguyên) -->
  <script src="https://unpkg.com/reveal.js/dist/reveal.js"></script>
  <script>
  Reveal.initialize({
    width: "100%",
    height: "100%",
    margin: 0.02,
    minScale: 0.2,
    maxScale: 2,
    slideNumber: true,
    center: false,
    hash: true,
    transition: 'slide',
    backgroundTransition: 'fade',
    controls: true,
    progress: true,
    plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMath ]
  });
  </script>

  <!-- Các script UI / slide list / clock giữ nguyên từ b2ds -->
  <script>
  // (Các hàm tạo danh sách slide, menu, đồng hồ, v.v. copy nguyên bản)
  function updateClock() {
    const now = new Date();
    const h = String(now.getHours()).padStart(2, '0');
    const m = String(now.getMinutes()).padStart(2, '0');
    const s = String(now.getSeconds()).padStart(2, '0');
    document.getElementById("clock").textContent = `${h}:${m}:${s}`;
  }
  setInterval(updateClock, 1000);
  updateClock();
  </script>

</body>
</html>
