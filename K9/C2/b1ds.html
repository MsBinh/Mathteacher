<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8">
  <title> L·ªöP TO√ÅN TH·∫¶Y B√åNH </title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Reveal.js CSS -->
  <link rel="stylesheet" href="https://unpkg.com/reveal.js/dist/reveal.css">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js/dist/theme/black.css" id="theme">
  <!-- Th√™m v√†o ph·∫ßn head, sau c√°c link CSS hi·ªán c√≥ -->
  <script src="https://unpkg.com/reveal.js/dist/reveal.js"></script>
  <script src="https://unpkg.com/reveal.js/plugin/notes/notes.js"></script>
  <script src="https://unpkg.com/reveal.js/plugin/markdown/markdown.js"></script>
  <script src="https://unpkg.com/reveal.js/plugin/highlight/highlight.js"></script>
  <script src="https://unpkg.com/reveal.js/plugin/math/math.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/reveal.js/plugin/highlight/monokai.css">
  <!-- MathJax -->
  <script>
    MathJax = {
      tex: { 
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']]
      },
      svg: { fontCache: 'global', linebreaks: { automatic: true } },
      chtml: { linebreaks: { automatic: true } }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
/* ===== TO√ÄN B·ªò GIAO DI·ªÜN (gi·ªØ nguy√™n t·ª´ b2ds) ===== */
.reveal .backgrounds {
  background: linear-gradient(135deg, #fdfdfd 0%, #f6f8fa 100%);
}
.reveal section {
  color: #020a44;
  font-family: "Segoe UI", "Helvetica Neue", Arial, sans-serif;
  font-size: 26px;
  line-height: 1.6;
  text-shadow: none;
  letter-spacing: 0.3px;
  transition: color 0.3s;
}
.reveal .slides section {
  max-width: 100% !important;
  width: 100% !important;
  height: auto;
  background: #ffffff;
  border-radius: 10px;
  box-shadow: 0 0 20px rgba(243, 5, 40, 0.08);
  padding: 20px;
  box-sizing: border-box;
}
.reveal h1, .reveal h2, .reveal h3 {
  color: #004aad;
  font-weight: 700;
  letter-spacing: 0.5px;
}
/* ... (b·ªè b·ªõt ph·∫ßn CSS l·∫∑p ƒë·ªÉ ng·∫Øn g·ªçn; gi·ªØ nguy√™n style ch√≠nh nh∆∞ b·∫°n c√≥) ... */

/* ===== TOOLBAR V·∫º (gi·ªØ nguy√™n) ===== */
#drawCanvas {
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  z-index: 9998;
  touch-action: none;
  pointer-events: none; /* JS s·∫Ω b·∫≠t pointer-events khi b·∫≠t ch·∫ø ƒë·ªô v·∫Ω */
}

.toolbar {
  position: fixed;
  top: 70px;
  left: 10px;
  background: white;
  border-radius: 10px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
  padding: 6px;
  z-index: 10000;
  display: flex;
  flex-direction: column;
  gap: 4px;
  width: 48px;
  align-items: center;
}

.toolbar button,
.toolbar select,
.toolbar input[type="color"],
.toolbar input[type="range"] {
  width: 100%;
  font-size: 10px;
  padding: 2px;
  height: 28px;
  box-sizing: border-box;
}

#toggleMenu {
  position: fixed;
  top: 15px;
  left: 40px;
  z-index: 99999 !important;
  font-size: 22px;
  background: rgba(0,0,0,0.45);
  color: #fff;
  border: none;
  border-radius: 6px;
  padding: 3px 8px;
  cursor: pointer;
}
#toggleMenu:hover {
  background: rgba(255,255,255,0.25);
}

/* Ensure reveal controls & progress visible above canvas */
.reveal .controls,
.reveal .progress,
.reveal .slide-number {
  z-index: 10005 !important;
  pointer-events: auto !important;
}

/* Ensure toolbar stays above controls but below toggleMenu */
#toolbar { z-index: 10010 !important; }
#toggleMenu { z-index: 10030 !important; }

/* (Ph·∫ßn CSS kh√°c c·ªßa trang gi·ªØ nguy√™n) */
  </style>
</head>

<body>
  <div class="topbar">
    <div class="topbar-title">L·ªöP TO√ÅN TH·∫¶Y B√åNH</div>
    <div class="clock" id="clock">--:--:--</div>
  </div>

  <div class="reveal">
    <div class="slides">
      <section>
        <h2>üìò B√ÄI 2</h2>
        <p>M√¥n To√°n - L·ªõp 12</p>
      </section>
      <section>
        <h2>üìò B√ÄI T·∫¨P TR·∫ÆC NGHI·ªÜM</h2>
      </section>
      <!-- C√°c slide kh√°c gi·ªØ nguy√™n -->
    </div>
  </div>

  <!-- Slide Menu / UI gi·ªØ nguy√™n... -->
  <div id="slideMenu" class="slide-menu">
    <div class="menu-header">
      <h3>üìã Danh s√°ch slide</h3>
      <button onclick="closeSlideMenu()" class="close-btn">√ó</button>
    </div>
    <div class="menu-content">
      <div id="slideList" class="slide-list"></div>
    </div>
  </div>

  <button id="menuToggle" class="menu-toggle" onclick="toggleSlideMenu()">üìã</button>

  <!-- ==== Canvas + Toolbar ==== -->
  <canvas id="drawCanvas" style="display:none;"></canvas>

  <div class="toolbar" id="drawToolbar" style="display:none;">
    <select id="tool">
      <option value="pen">‚úèÔ∏è B√∫t</option>
      <option value="line">üìè ƒê∆∞·ªùng</option>
      <option value="rect">‚¨õ Ch·ªØ nh·∫≠t</option>
      <option value="parallelogram">‚ñ± B√¨nh h√†nh</option>
      <option value="circle">‚ö™ Tr√≤n</option>
      <option value="dashedLineBtn">‚Äì ‚Äì</option>
      <option value="ellipseBtn">‚¨≠ Elip</option>
      <!-- Th√™m 3 c√¥ng c·ª• m·ªõi -->
      <option value="box">üì¶ H·ªôp 3D</option>
      <option value="pyramid3">üî∫ Ch√≥p tam gi√°c</option>
      <option value="pyramid4">üî≤ Ch√≥p t·ª© gi√°c</option>
      <option value="sphere">‚öΩ C·∫ßu</option>
    </select>
    <input type="range" id="draw-width" min="1" max="5" value="2" />
    <input type="color" id="colorPicker" value="#6b21a8" />
    <button id="undoBtn" title="Undo">‚Ü©Ô∏è</button>
    <button id="clearBtn">üßπ Xo√°</button>
    <button id="saveBtn">üíæ L∆∞u</button>
    <button id="exitBtn">‚ùå Tho√°t</button>
  </div>

  <button id="toggleMenu">‚ò∞</button>

  <script>
/* === SCRIPT V·∫º (b·∫Øt ngu·ªìn t·ª´ b2ds) === */
/* M√¨nh ch·ªâ th√™m: history (undo), v√† 3 case v·∫Ω: box, pyramid3, pyramid4.
   Kh√¥ng s·ª≠a logic v·∫Ω kh√°c. */

const canvas = document.getElementById("drawCanvas");
const ctx = canvas.getContext("2d");
const toggleBtn = document.getElementById("toggleMenu");
const toolbar = document.getElementById("drawToolbar");
const clearBtn = document.getElementById("clearBtn");
const saveBtn = document.getElementById("saveBtn");
const exitBtn = document.getElementById("exitBtn");
const colorPicker = document.getElementById("colorPicker");
const toolSelect = document.getElementById("tool");
const widthPicker = document.getElementById("draw-width");
const undoBtn = document.getElementById("undoBtn");

let lineWidth = 2;
widthPicker.oninput = () => lineWidth = parseInt(widthPicker.value);

let isDrawing = false;
let isDrawMode = false;
let startX = 0, startY = 0, lastX = 0, lastY = 0;
let currentTool = "pen";
let imageBeforeShape;

// HISTORY cho Undo (ho√†n t√°c n√©t g·∫ßn nh·∫•t)
let history = [];

// m∆∞·ª£t h∆°n
ctx.lineJoin = "round";
ctx.lineCap = "round";

// k√≠ch th∆∞·ªõc canvas (ƒë∆°n gi·∫£n, gi·ªØ nguy√™n nh∆∞ b2ds)
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener("resize", resizeCanvas);

// b·∫≠t/t·∫Øt v·∫Ω
toggleBtn.onclick = () => {
  isDrawMode = !isDrawMode;
  if (isDrawMode) {
    canvas.style.display = "block";
    toolbar.style.display = "flex";
    canvas.style.pointerEvents = "auto"; // b·∫≠t t∆∞∆°ng t√°c khi v·∫Ω
  } else {
    canvas.style.display = "none";
    toolbar.style.display = "none";
    canvas.style.pointerEvents = "none";
  }
};

// tho√°t
exitBtn.onclick = () => {
  isDrawMode = false;
  canvas.style.display = "none";
  toolbar.style.display = "none";
  canvas.style.pointerEvents = "none";
};

// ch·ªçn c√¥ng c·ª•
toolSelect.onchange = () => currentTool = toolSelect.value;

// undo: ho√†n t√°c 1 b∆∞·ªõc (n√©t g·∫ßn nh·∫•t)
undoBtn.onclick = () => {
  if (history.length > 0) {
    const last = history.pop();
    try {
      ctx.putImageData(last, 0, 0);
    } catch (e) {
      // n·∫øu putImageData l·ªói do mismatch k√≠ch th∆∞·ªõc, clear v√† ignore
      ctx.clearRect(0,0,canvas.width,canvas.height);
    }
  }
};

// xo√° to√†n b·ªô
clearBtn.onclick = () => ctx.clearRect(0, 0, canvas.width, canvas.height);

// l∆∞u ·∫£nh
saveBtn.onclick = () => {
  const link = document.createElement("a");
  link.download = "ban_ve.png";
  link.href = canvas.toDataURL();
  link.click();
};

// fullscreen button (gi·ªØ nguy√™n)
const fullBtn = document.createElement("button");
fullBtn.textContent = "‚õ∂ Full";
fullBtn.title = "To√†n m√†n h√¨nh";
fullBtn.onclick = () => {
  if (!document.fullscreenElement)
    document.documentElement.requestFullscreen().catch(() => {});
  else
    document.exitFullscreen();
};
toolbar.appendChild(fullBtn);

// l·∫•y v·ªã tr√≠ ch√≠nh x√°c
function getPos(e) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  if (e.touches && e.touches.length > 0)
    return { x: (e.touches[0].clientX - rect.left) * scaleX, y: (e.touches[0].clientY - rect.top) * scaleY };
  return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
}

// b·∫Øt ƒë·∫ßu v·∫Ω
function startDraw(e) {
  if (!isDrawMode) return;
  e.preventDefault();
  const pos = getPos(e);

  // L∆ØU tr·∫°ng th√°i tr∆∞·ªõc khi v·∫Ω (cho Undo: ho√†n t√°c n√©t g·∫ßn nh·∫•t)
  try {
    history.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
  } catch (err) {
    // ignore n·∫øu getImageData l·ªói (v√≠ d·ª• canvas ch∆∞a c√≥ k√≠ch th∆∞·ªõc)
  }

  isDrawing = true;
  startX = lastX = pos.x;
  startY = lastY = pos.y;
  ctx.strokeStyle = colorPicker.value;
  ctx.lineWidth = lineWidth;
  ctx.beginPath();
  ctx.moveTo(startX, startY);
  if (currentTool !== "pen") {
    try { imageBeforeShape = ctx.getImageData(0, 0, canvas.width, canvas.height); } catch(e){ imageBeforeShape = null; }
  } else {
    imageBeforeShape = null;
  }
}

// v·∫Ω khi r√™
function drawMove(e) {
  if (!isDrawing || !isDrawMode) return;
  e.preventDefault();
  const pos = getPos(e);
  ctx.strokeStyle = colorPicker.value;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash([]);

  if (currentTool === "pen") {
    ctx.beginPath();
    ctx.moveTo(lastX, lastY);
    ctx.lineTo(pos.x, pos.y);
    ctx.stroke();
    lastX = pos.x; lastY = pos.y;
  } else {
    // kh√¥i ph·ª•c n·ªÅn tr∆∞·ªõc shape live preview
    if (imageBeforeShape) {
      try { ctx.putImageData(imageBeforeShape, 0, 0); } catch(e){ /* ignore */ }
    } else {
      // n·∫øu kh√¥ng c√≥ imageBeforeShape, x√≥a ph·∫ßn v·∫Ω t·∫°m
      // (ƒë·ªÉ tr√°nh ch·ªìng l·ªõp)
      // ctx.clearRect(0,0,canvas.width,canvas.height);
    }

    switch (currentTool) {
      case "line":
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        break;

      case "dashedLineBtn":
        ctx.setLineDash([8,6]);
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        ctx.setLineDash([]);
        break;

      case "rect":
        ctx.strokeRect(startX, startY, pos.x - startX, pos.y - startY);
        break;

      case "circle":
        const r = Math.hypot(pos.x - startX, pos.y - startY);
        ctx.beginPath();
        ctx.arc(startX, startY, r, 0, Math.PI*2);
        ctx.stroke();
        break;

      case "ellipseBtn":
        ctx.setLineDash([6,4]);
        ctx.beginPath();
        ctx.ellipse(startX, startY, Math.abs(pos.x - startX), Math.abs(pos.y - startY), 0, 0, Math.PI*2);
        ctx.stroke();
        ctx.setLineDash([]);
        break;

      case "sphere":
        const rs = Math.abs(pos.x - startX);
        ctx.beginPath();
        ctx.arc(startX, startY, rs, 0, Math.PI*2);
        ctx.stroke();
        ctx.setLineDash([6,4]);
        ctx.beginPath();
        ctx.ellipse(startX, startY, rs, rs/2, 0, Math.PI, 2 * Math.PI);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.ellipse(startX, startY, rs, rs/2, 0, 0, Math.PI);
        ctx.stroke();
        break;

      case "parallelogram":
        const width = pos.x - startX;
        const height = pos.y - startY;
        const offset = width * 0.3;
        ctx.beginPath();
        ctx.moveTo(startX + offset, startY);
        ctx.lineTo(startX + width + offset, startY);
        ctx.lineTo(startX + width - offset, startY + height);
        ctx.lineTo(startX - offset, startY + height);
        ctx.closePath();
        ctx.stroke();
        break;

      /* ==== TH√äM: BOX (H·ªòP 3D) ==== */
      case "box":
        {
          const w = pos.x - startX;
          const h = pos.y - startY;
          const depth = Math.min(Math.abs(w), Math.abs(h)) * 0.3;
          // front face
          ctx.beginPath();
          ctx.strokeRect(startX, startY, w, h);
          // back face (offset by depth up-left)
          ctx.strokeRect(startX + depth, startY - depth, w, h);
          // connect corners
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(startX + depth, startY - depth);
          ctx.moveTo(startX + w, startY);
          ctx.lineTo(startX + w + depth, startY - depth);
          ctx.moveTo(startX, startY + h);
          ctx.lineTo(startX + depth, startY + h - depth);
          ctx.moveTo(startX + w, startY + h);
          ctx.lineTo(startX + w + depth, startY + h - depth);
          ctx.stroke();
        }
        break;

      /* ==== TH√äM: CH√ìP TAM GI√ÅC (pyramid3) ==== */
      /* ==== C·∫¢I TI·∫æN: CH√ìP TAM GI√ÅC 3D (pyramid3) ==== */
        case "pyramid3": {
          // x√°c ƒë·ªãnh 3 ƒë·ªânh ƒë√°y (tam gi√°c n·∫±m tr√™n m·∫∑t ph·∫≥ng ƒë√°y)
          const baseLeft = { x: startX, y: pos.y };
          const baseRight = { x: pos.x, y: pos.y };
          const baseMid = { x: (startX + pos.x) / 2, y: pos.y - (pos.y - startY) * 0.2 };

          // ƒë·ªânh ch√≥p (cao h∆°n ƒë√°y)
          const apex = { 
            x: (startX + pos.x) / 2, 
            y: startY - Math.abs(pos.y - startY) * 0.7 
          };

          ctx.beginPath();
          ctx.setLineDash([]); // n√©t li·ªÅn

          // v·∫Ω m·∫∑t tr∆∞·ªõc (2 c·∫°nh b√™n + c·∫°nh ƒë√°y tr∆∞·ªõc)
          ctx.moveTo(apex.x, apex.y);
          ctx.lineTo(baseLeft.x, baseLeft.y);
          ctx.lineTo(baseRight.x, baseRight.y);
          ctx.closePath();
          ctx.stroke();

          // v·∫Ω c·∫°nh ph√≠a sau (·∫©n - n√©t ƒë·ª©t)
          ctx.setLineDash([6, 4]);
          ctx.beginPath();
          ctx.moveTo(apex.x, apex.y);
          ctx.lineTo(baseMid.x, baseMid.y);
          ctx.stroke();
          ctx.setLineDash([]);
          break;
        }


      /* ==== TH√äM: CH√ìP T·ª® GI√ÅC (pyramid4) ==== */
      case "pyramid4":
        {
          const w4 = pos.x - startX, h4 = pos.y - startY;
          const apexX = startX + w4 / 2;
          const apexY = startY - h4 / 1.5; // apex above the rectangle
          ctx.beginPath();
          // base rectangle (front)
          ctx.rect(startX, startY, w4, h4);
          ctx.stroke();
          // connect base corners to apex
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(apexX, apexY);
          ctx.moveTo(startX + w4, startY);
          ctx.lineTo(apexX, apexY);
          ctx.moveTo(startX, startY + h4);
          ctx.lineTo(apexX, apexY);
          ctx.moveTo(startX + w4, startY + h4);
          ctx.lineTo(apexX, apexY);
          ctx.stroke();
        }
        break;

      case "pyramid3": // duplicate safe-guard
        break;

      default:
        break;
    }
  }
}

// k·∫øt th√∫c
function endDraw() { isDrawing = false; }

canvas.addEventListener("mousedown", startDraw);
canvas.addEventListener("mousemove", drawMove);
canvas.addEventListener("mouseup", endDraw);
canvas.addEventListener("mouseleave", endDraw);
canvas.addEventListener("touchstart", startDraw, { passive: false });
canvas.addEventListener("touchmove", drawMove, { passive: false });
canvas.addEventListener("touchend", endDraw);
  </script>

  <!-- Reveal.js init (gi·ªØ nguy√™n) -->
  <script src="https://unpkg.com/reveal.js/dist/reveal.js"></script>
  <script>
  Reveal.initialize({
    width: "100%",
    height: "100%",
    margin: 0.02,
    minScale: 0.2,
    maxScale: 2,
    slideNumber: true,
    center: false,
    hash: true,
    transition: 'slide',
    backgroundTransition: 'fade',
    controls: true,
    progress: true,
    plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMath ]
  });
  </script>

  <!-- C√°c script UI / slide list / clock gi·ªØ nguy√™n t·ª´ b2ds -->
  <script>
  // (C√°c h√†m t·∫°o danh s√°ch slide, menu, ƒë·ªìng h·ªì, v.v. copy nguy√™n b·∫£n)
  function updateClock() {
    const now = new Date();
    const h = String(now.getHours()).padStart(2, '0');
    const m = String(now.getMinutes()).padStart(2, '0');
    const s = String(now.getSeconds()).padStart(2, '0');
    document.getElementById("clock").textContent = `${h}:${m}:${s}`;
  }
  setInterval(updateClock, 1000);
  updateClock();
  </script>

</body>
</html>
